# 
> 2018000模板




第 9 章　指数函数和对数函数


这是关于指数函数和对数函数的重要且悠久的一章.在我们回顾完这些函数的性质之后, 我们需要对它们做一些微积分的运算.事实表明, 有一个特殊的底数, 就是数e, 它会产生特别好的结果.特别是, 对ex和loge(x)做微积分的运算要比处理像2x和log3(x)这样的量更简单些. 因此,s 我们需要花一些时间来看看e.我们也想看看其他的情况：总之, 本章计划就是检验下列话题：

指数函数和对数函数的基本知识的回顾,以及它们是如何关联在一起的;



e的定义和性质;



如何对指数函数和对数函数求导;



如何求解涉及指数函数和对数函数的极限问题;



对数函数的微分;



指数增长和衰退;



双曲函数.





9.1　基础知识


在你开始对指数函数和对数函数做微积分的运算之前,你真的需要理解它们的性质. 基本上来说, 除了对数函数真正的定义之外,你需要知道三点：指数法则、对数和指数的关系及对数法则.





9.1.1　指数函数的回顾


大致思想是, 我们取一个正数, 称之为底数,并将它提升至一个被称为指数的幂：

底数指数.

例如, 数2- 5 / 2是一个以2为底且指数为- 5 /2的指数. 重要的是, 你要知道所谓的指数法则,它会有效地告诉你如何对指数进行运算. 很可能你之前已经看到过这些了,但在这里它们会再一次提醒你. 对于任意的底数b >0和实数x与y：

1. 任意非零数的零次幂是1.

2. 一个数的一次幂正好是该数本身.

3. 当你将两个带有相同底数的指数相乘时,就是将指数相加.

4. 当你将两个带有相同底数的指数相除时, 就是将分子的指数减去分母的指数.

5. 当你取指数的指数时,就是将指数相乘.

你也应该知道指数函数的图像是什么样子的.我们已经在1.6节看过一些了, 但不管怎样,我们将很快地再次讨论这些图像.





9.1.2　对数函数的回顾


对数——给很多学生的心灵带来恐惧的一个词. 看仔细,我们要来看看如何处理这些怪兽了. 假设,你想要从以下方程中求解x：



你可以将x从指数的位置移下来的方法是在方程两边取对数.由于左边的底数是2, 对数的底就是2. 事实上, 根据定义,上述方程的解是



换句话说,你必须将2提升几次幂才能得到7呢？答案是log2(7). 这个特别的数不能被简化, 但log2(8)会怎样呢？问问自己,你必须将2提升几次幂才能得到8呢？由于23 = 8,我们需要的幂次就是3. 因此, log2(8) = 3.

让我们回到方程2x = 7. 我们知道这意味着x = log2(7). 如果我们现在将x的值插入到原始方程中,我们得到下面这个看起来很奇怪的公式



更一般地, logb(y)}是为了得到y你必须将底数b提升的次幂. 这意味着, 对于给定的b和y, x = logb(y)是方程bx = y的解. 将x的值代入,我们得到公式





它对于任意的y > 0和b > 0(除b = 1)都成立. 嗨,为什么我要坚持让b和y都是正的呢？首先, 如果b是负的,那么很多怪诞的事情就会发生. 量bx可能就没有定义了. 例如, 如果b= - 1且x = 1 / 2, 那么bx就是(- 1)1 / 2,它是 (真是的!). 因此, 我们要避免所有这些,就得要求b> 0. 这样, 取任意次幂的bx就没有问题了. 另一方面,bx总是正的! 因此, 如果y = bx, 那么一定有y > 0. 这意味着,取一个负数或0的对数是毫无意义的. 毕竟, 如果logb(y)是为了得到y你必须将底数b提升的次幂,那你就不可能将b提升到一个次幂而得到一个负数或0, 那么y就不可能是负数或0. 你只能取一个正数的对数.

你或许也注意到, 我提及了b = 1不好. 如果你将b =1代入上述公式blogb(y) = y, 你会得到1log1(y) = y. 问题是, 我提升到任意次幂结果仍然是1,但是y可能不是1, 因此这个方程毫无意义,即根本就不存在底数为1的对数. 那么底数为1 / 2又如何呢？这没什么,但是很少情况需要一个底数为1 / 2的对数, 因为事实表明,对于任意的y, log1 / 2(y) = -log2(y). (通过设y = (1 / 2)x并且注意到y也等于2-x,你可以证明该式.) 同理, 对于任意的介于0和1之间的底数b, 对于所有的y, logn(y)= - log1 / b(y), 且1 / b大于1. 因此,从现在开始, 我们将一直假设底数b大于1.





9.1.3　对数函数、指数函数及反函数


使用反函数, 我们可以对上述看到的一切进行更精密的描述.固定一个底数b > 1并且设f(x) = bx.函数f的定义域是且值域为(0, ∞). 由于它通过了水平线检验, 因此它有反函数, 我们称之为g. g的定义域是f的值域, 即(0, ∞), 而g的值域就是f的定义域, 即.我们说, g是底数为b的对数; 事实上, 根据定义g(x) = logb(x).记得反函数的图像就是原始函数关于镜面直线y = x的映像,我们可以在同一坐标系下画出f(x) = bx及其反函数g(x) = logb(x)的图像, 如图9-1.



图　9-1

由于f和g互为反函数, 我们知道f(g(x)) = x及g(f(x)) = x.(第一个事实仅在x > 0时成立, 正如我们将要看到的.)我们来对这两个事实一个一个地进行解释.

1. 我们先从f(g(x)) = x开始.由于g是对数函数, 因此x最好是正的(请记住,你只能取一个正数的对数.) 现在, 我们来仔细看看量f(g(x)). 你以一个正数x开始, 将它代入g中,g是底数为b的对数. 然后, 你再对结果进行指数运算,即, 你将b提升到g(x)次幂.你会以原始的数结束本次运算! 事实上, 由于f(x) = bx且g(x) = logb(x), 公式f(g(x)) = x就是说



这就是上一节中的其中一个公式(用x替换了y). 只要底数相同, 对数的指数就是原始的数!

2. 另一个事实是g(f(x)) = x对于所有的x都成立. 现在我们取一个数x, 将b提升至数x次幂,然后取底数为b的对数. 我们再一次得到原始的数x. 这就好像是,我们取一个正数, 先平方然后再取平方根——你会得到原始的数.由于f(x) = bx且g(x) = logb(x), 方程g(f(x)) = x变为

　(对于任意的实数x及b > 1).



例如, 当我们在上一节中看方程2x = 7时,你可以对方程两边取log2, 并得到



　等号左边正好就是x, 因为指数的对数就是原始的数(只要底数相同!). 我们再来快速地看一个例子, 求：



我们仅仅是对方程两边取log3,得到：



左边恰好就是x2 - 1, 因此我们有. 这意味着





9.1.4　对数法则


上述9.1.1节中的所有的指数法则都有对数形式, 它们(足够奇怪的)被称为对数法则.事实上还有一个附加的对数法则——换底法则——它没有相应的指数法则(见下面的#6).1因此,下面是对于任意的底数b> 1 和正的实数x与y的有效法则：

1事实上, 对于指数也有一个换底法则：对于b > 0、 c > 1及 x> 0, 有. 因为涉及对数,所以, 一般情况下,它都不包含在指数法则列表中.

1.

2.

3. 乘积的对数是对数的和.

4. 商的对数是对数的差.

5. 对数将指数移至对数之前.在该方程中, y可以是任意的实数(正的、负的或零).

6. 换底法则：对于任意的底数b > 1和c > 1及任意的数x >0,



这意味着,所有的带有不同底数的对数函数其实是互为常数倍的. 事实上,上述方程说明



其中K是常数(它碰巧等于. 当我说“常数”时, 我的意思是, 它不依赖于x.我们可以推出结论, 和 的图像非常相似, 你只要将第二个函数的图像垂直拉伸K倍就能得到第一个函数的图像.

　现在,我们来看看为什么这些法则成立. 如果你想, 你可以跳到下一节,但是请相信我, 如果你继续阅读, 你会对对数函数有一个更好的理解.不管怎样, 上述的#1相当简单：因为对于任意的底数b > 1, b0 =1, 所以我们有.同理得#2：由于对于任意的底数b > 1, b1 = b,所以我们可以写出.

第三个法则有点难度. 我们必须证明, 其中x和y是正的且b > 1. 我们由重要的事实开始,以上我们已经注意到很多次了(用A替换之前的变量)：对于任意的A >0,



如果我们使用三次,就是用x、y及xy分别替换A, 我们得到

　　及

现在, 你可以将第一个和第二个方程相乘,然后和第三个方程相比较,会得到



这又怎么样呢？好吧,在左边使用指数法则的#3; 由于我们必须把指数相加,故方程变为



现在,在方程两边取以b为底的对数来消除底数b; 这样, 我们就得到了对数法则. 这并不太糟!

　至于上述的法则#4,我将它留给你来证明, 证明过程几乎和我们刚刚证明的#3是一样的.因此, 我们去看看#5吧. 我们想要证明, 其中x > 0、b > 1且y是任意实数. 为了求证, 我们由上述的重要事实开始,但用xy替换A, 得到



这给了我们一个怪诞的方式来表达xy.我们也可以用x替换A, 得到



然后将两边提升至次幂y：



等号左边正是指数法则#5中的 (见9.1.1节). 因此, 对于xy,我们有两种不同的表达, 它们必须相等：



再次对方程两边取底数为b的对数, 上式简化为我们的对数法则



最后, 我们只需要证明换底法则了. 事实上, 我们就是要证明



你看, 如果它是成立的, 那么,我们在等号两边同除以,会得到上述#6描述的法则. 不管怎样, 我们取上述方程,并将左右两边分别作为c的次幂, 相应地得到

　及

右边很简单：根据我们的重要事实,它就是x. 但左边呢？我们再次使用指数法则#5, 可以很有技巧地写出



由我们的重要事实(两次了)可知, 及,我们推导出结论



因此, 上述这两个量

　及

正好简化为x! 它们必须相等,那么如果我们消除底数c(使用以c为底的对数),我们就能得到想要的方程



如果你尽心尽力地全面理解了所有的这些证明, 你当然做得很棒.





9.2　e的定义


到目前为止,我们还没有做过涉及指数函数或对数函数的任何微积分的运算.让我们开始做些吧. 我们会先从极限开始, 然后进入导数. 在这一过程中,我们需要引入一个新的常数e, 和π一样, 它也是一个特别的数.当你开始对数学进行足够深的探索时, 它就会出现.研究e的起源的一种方法涉及一些金融课程.





9.2.1　一个有关复利的例子


很久以前, 一个名叫伯努利(Bernoulli)的家伙回答了一个有关复利的问题.下面就是该问题. 我们假设, 你在一家银行有一个银行账户,该银行付给你一个慷慨的年利率12%, 是一年一次的复利的形式.你将一笔初始存款存入账户. 每一年你的财富增加12%. 这意味着,n年后, 你的财富会增加到原来的(1 + 0.12)n倍.特别地, 一年后, 你的财富就是(1 + 0.12)乘以原始存款. 如果你最开始存入了$100, 年底你会得到$112.

现在, 假设你发现另一家银行, 它也提供12%的年利率,但现在它是一年两次的复利的形式. 当然, 对于半年, 你不会得到12%;你必须用它除以2. 基本上, 这意味着, 每6个月你会得到6%的利息. 因此, 如果你将钱存入这个银行账户, 那么, 一年后,它会以6%的利息复利两次; 结果就是你的财富会增加(1 +0.06)2, 其结果是1.123 6. 因此, 如果你最开始存入了$100, 年底你会得到$112.36.

第二个账户的收益比第一个略好一些. 如果你思考的话,这句话是有意义的——复利是有益的, 因此, 在相同的年利率下,复利越频繁结果会越好. 我们来试着计算一下年利率为12%的每年3次的复利. 我们取12%, 并将它除以3会得到4%,然后, 复利三次, 我们的财富将会增加到原来的(1 + 0.04)3倍, 其结果是1.124 864. 这还是高了些.那要是每年4次呢？那将是(1 + 0.03)4倍,结果近似为1.125 5, 这就更高了. 现在的问题是,它何时停下来？如果你以相同的年利率计算越来越频繁的复利,一年后你会得到大把大把的现金吗？或者这一切是有限制的吗？





9.2.2　我们的问题的答案


为了回答我们的问题, 让我们来求助于一些符号. 首先, 我们假设,我们以年利率12%做每年n次的复利. 这意味着, 我们每一次做复利,复利的利率是0.12 / n. 在一年中发生了n次后,我们的原始财富会增长的倍数为



我们想要知道, 如果我们的复利越来越频繁时会怎样.事实上,我们允许n变得越来越大. 即, 我们想知道, 当n → ∞时的极限会怎样：



这到底是什么呢？

如果知道当利率不是12%时会发生什么情况, 这也很好. 因此,我们用r代替0.12, 并关心更一般的极限



如果该极限(我称之为L的结果是无限的,那么通过越来越频繁的复利, 你在一年中可以得到越来越多的钱.另一方面, 如果它的结果是有限的, 我们必须得出结论,在一个年利率r的情况下, 不管我们的复利多么频繁,我们的财富的增长幅度都是有限制的. 这将是一种“速率极限,”或更精确地说, 一种“财富!--!增长极限.”给定一个固定的年利率r, 以及一年的游戏时间, 不管复利有多么频繁,你都不可能让你财富的增长超过上述极限的值(假设它是有限的).

出现在极限中的量(1 + r / n)n是复利公式的特例.一般地, 假设你以现金$A开始, 并且你将它存入一个银行账户,年利率为r, 复利是每年n次的形式. 那么, 在t年中,复利将以比率r / n的形式出现nt次. 因此, t年后,你的财富由以下公式给出：

每一年复利n次，年利率为r，t年后的财富.



因此, 我们就从$1开始(故A = 1), 并来看看一年(故t =1)后会发生什么,然后看看如果我们在一年中复利得越来越频繁时极限会怎样.

现在, 我们来计算极限：



首先, 我们设h = r / n, 这样n = r /h. 那么, 当n → ∞时, 我们看到h → 0+(由于r是常数), 故



现在我们可以使用指数法则来写出



我们来变个魔术, 设



解题窍门在哪里呢？好吧, 极限或许不存在. 事实表明, 它存在.如果你想要知道原因的话, 请参见附录A的A.5节. 不管怎样,我们有一个特殊的数e, 我们马上就会去看看有关它的更多的细节.尽管如此, 我们先回到极限中. 现在我们有



这就是我们要找的答案!我们将以上所有的步骤综合在一起会看到它是如何运算的. 因为h = r /n, 我们有



这意味着,如果你在一个年利率r上复利得越来越频繁时,你的财富会增长到一个非常接近于er的量, 但绝不会超过它.量er就是我们要找的“财富-增长极限”.得到这个增长率的唯一途径就是你是否连续地复利, 即, 一直复利!

因此, 假设你由$A的现金开始, 并将它存入一个银行账户,它是在一个年利率r上连续地复利. 一年后, 你会有$A er.两年后, 你会有.我们很容易一直重复这个过程, 并看到t年后, 你会有. 事实上, 由于指数法则, 对于分数年也成立. 因此, 由$A开始, 我们有

在年利率r上连续地复利t年后的财富



我们比较该公式和. 量和看起来很不同, 但是对于很大的n,它们几乎是一样的.





9.2.3　关于e和对数函数的更多内容


让我们来更好地看一下数e吧. 记得



我们可以用1替换r, 得到



当然, r = 1对应于一个100%的年利率. 我们列一个的值的表,对于不同的n值, 结果保留三位小数：

n 1 2 3 4 5

2 2.25 2.353 2.441 2.488

10 100 1 000 10 000 100 000

2.594 2.705 2.717 2.718 2.718

在 这个巨大的利率下,即使一年复利一次也可以使你的钱翻倍(那就是在第二列的下面一行的“2”).此外, 这看起来好像是我们不可能比2.718做得更好,即使我们每一年复利很多很多次. 我们的数e, 就是上表中的第二行数在n → ∞时的极限, 结果是一个无理数, 其小数展开式如下：



它看起来像在开始附近有一种样式, 带有重复的串“1828”,但这只是个巧合. 实际上, 知道e比2.7大一点就已经足够了.

现在, 如果x = er, 那么. 事实表明, 取以e为底的对数是如此常见的事情,以至于我们甚至可以将它用另一种方式写出：ln(x)代替. 表达式“ln(x)”不读作“linx”或任意和它相像的读音,如“log x”, 或可能是“ellen x”,亦或你感觉特别奇怪的读法——“x的自然对数”.事实上, 大多数数学家们写不带底数的log(x)来表示和及ln(x)相同的意思. 底数为e的对数称为自然对数. 在下一节,当对关于x求导时,我们会看到为什么它是这么自然的一个原因.

因为我们有了一个新的底数e, 以及以e为底时的一个新的对数写法,让我们再来看看至今已经看到的对数法则和公式吧. 看看你是否相信,对于x > 0且y > 0, 下列公式都成立：





(事实上, 在第二个公式中,x甚至可以是负数或0, 在最后一个公式中, y可以是负数或0.)不管怎样, 知道在这种形式下的这些公式真的是很值得的, 因为从现在起,我们几乎总是要和自然对数打交道.

　在我们继续讨论对数函数和指数函数求导之前,再来看一点. 假设, 你取重要极限



这一次, 替换h = 1 / n.正如我们在上一节注意到的, 当n → ∞时, 我们有h → 0+. 因此, 我们用1 / h替换n, 得到



这是一个右极限. 事实上, 你可以用h → 0替换h → 0+, 对于双侧极限仍然成立. 我们所需的就是证明,左极限是er, 然后, 左极限等于右极限, 故双侧极限也等于er. 因此, 我们考虑



用 - t替换h; 那么, 当h → 0-时, t → 0+.(当h是一个很小的负数时, t = - h就是一个很小的正数.) 故



由于对于任意的A ≠ 0, A- 1 = 1/ A, 我们可以重新将极限写成



分母就是带有利率-r而不是r的经典极限. 这意味着, 当t → 0+时, 在极限中,分母趋于e-r. 因此, 综合起来我们有



因为e-r = 1 / er, 故最后一步成立. 这样, 我们完成了想要的证明.我们在所有的公式中将r改为x(为什么不呢?)并总结我们已经发现的事实：

　及



当x = 1时,我们得到e的两个公式：

　及



这些公式非常重要! 在下面的9.4.1节中,我们将看到一些如何使用它们的例子. 马上,我们也会使用其中之一来对对数函数求导.





9.3　对数函数和指数函数求导


现在情形变复杂了. 令g(x) = logb(x). 那么g的导数是什么呢？我们使用定义,



如何来化简这个杂乱的公式呢？我们当然使用对数法则! 首先,使用9.1.4节中的法则#4, 将对数的差转化为对数的商：



我们可以将分式化简为(1 + h / x),但是我们也需要使用对数法则#5, 将因子1 / h提至指数的位置. 故



现在让我们忘记logb.当h趋于0时,



会怎样呢？即,



是什么呢？在上一节中,我们看到了



因此, 如果我们用1 / x替换r,那么就会有



所以, 如果回到g'(x)的表达式中, 我们会看到



事实上,我们甚至可以再次使用对数法则#5将表达式进一步化简——将幂1 /x提至对数符号之前, 这样我们就证明了



现在, 我们设b = e, 这样,我们就能求以e为底的对数的导数了, 我们得到



但是请等一下, 根据对数法则#2, loge(e)等于1. 因此, 这意味着



这非常好. 这实际上非常非常好.在某种程度上的确令人惊异. 谁会想到loge(x)的导数就是1 /x呢？这就是为什么以e为底的对数被称为自然对数的原因之一.我们将loge(x)写作ln(x)(在上一节我们给出了这个定义), 得到重要公式





此外, 以上的logb(x)的导数的表达式可以通过换底法则(就是9.1.4节中的#6)用自然对数写出.你看, 通过将底换为e, 得到



因此我们有





这是表达一个不是以e为底的对数的导数的最好的方式了.现在来看看：如果y = bx, 那么, 我们知道x = logb(y). 现在对其关于y求导. 使用上述公式并用y替换x,我们得到



根据链式求导法则, 可以上下颠倒得到



由于y = bx, 我们就证明了下面这个很好的公式





特别是,如果b = e, 那么ln(b) = ln(e) = 1.(这就是伪装的对数法则#1. 记住, ln(e) = loge(e) = 1.) 因此,如果b = e, 公式变为





这是一个非常怪异的公式. 如果h(x) = ex, 那么也有h'(x) = ex(函数h是它自身的导数!). 当然, ex的二阶导(关于x的)还是ex, 三阶导也一样,四阶导也一样, 等等.

指数函数和对数函数求导的例子

　现在,我们来看一下如何应用上述公式吧. 首先, 如果y = e-3x,那么是什么？那好, 如果u = - 3x, 那么y =eu. 我们有

　及

根据链式求导法则,



注意到,我们在最后一步用 - 3x替换了u. 事实上, 这是一个精妙法则的特例,如果a是常数, 那么



　通过设u = ax, 我们可以用同样的方法证明此公式. 实际上,它和我们在7.2.1节结尾部分看到的原理是一样的：如果用ax替换x, 那么当你求导时,将会提出一个附加的因子a. 因此, 例如对ln(8x)关于x求导应该没有问题. 事实上,



由于ln(8x)关于x的导数是1 / x. 现在,我们删除因子8会看到



　这很奇怪——ln(8x)的导数和ln(x)的导数是一样的!如果你思考的话就不会觉得那么怪异了：因为ln(8x) =ln(8) + ln(x), 因此, 事实上, 量ln(8x)和ln(x)就相差一个常数,故关于x它们有相同的导数.

这儿有一个比较难的例子：

如果 ,　 是什么?

我们来使用乘积法则和链式求导法则. 设u = ex2及v = log3(5x - sin(x)), 故y = uv.对于乘积法则, 需要对u和v(关于x)求导, 因此,让我们一个一个地进行. 我们从u = ex2开始, 设t = x2,因此u = et; 然后, 使用链式求导法则, 有



至于v, 令s = 5x - sin(x), 结果v = log3(s).根据链式求导法则,



我们在这里使用的公式就是来自上一节中的logb(x)(b= 3)和bx(b现在等于5.) 的导数公式. 不管怎样, 由于y = uv, 有



像往常一样, 这有些杂乱,但是这个例子的确说明了所涉及的要点：只要你知道指数函数和对数函数求导的基本公式(即是上一节中的加框公式),那么求解就完全没有问题了.





9.4　如何求解涉及指数函数和对数函数的极限


现在到了来看看如何求解一些极限问题的时候了.就我们已经看到的之前的所有极限来说, 非常重要的一点就是要注意,你是否在0 (即非常小的变量)的附近、∞或- ∞(相当大的变量)的附近、或其他的既不太小也不太大的某地方来评估函数的.我们将对这些情况中的一部分关于指数函数和对数函数进行更详细的考察.尽管如此, 让我们开始吧, 从涉及e的定义的极限出发.





9.4.1　涉及 e 的定义的极限


　我们考虑下列极限：



它看上去和9.2.3节中的涉及e的极限



非常相似. 如果我们取这个极限,并在我们所能看到的地方用3h2代替h, 那么我们得到



这几乎就是我们想要的. 我们所需要做的就是注意, 当h → 0时, 3h2 → 0, 故



　同理,我们可以证明(例如)



　事实上,如果你用任意的当h → 0时趋于0的量替换h, 就像3h2或sin(h), 则极限仍是e. 那么



会怎样呢？

由于当h → 0时, cos(h) → 1,因此你不能仅仅重复之前的论证. 事实上, 如果你只要将h = 0代入到表达式中, 那么你会得到(1 + 1)1 =2, 故上述极限实际上等于2.

　现在, 我们考虑



这里的h2和3h2这两项不匹配. 它们很相似, 但是系数不同.我们需要将指数1 / 3h2写作(1 / h2)×(1 / 3), 并使用指数法则：



由于h2是匹配的项,故大括号中的部分趋于e, 则整个极限是e1 / 3.

　这里有一个略难一些的例子：以下极限



的值是什么？ 这很烦人, 但这些很小的量- 5h3和h3并不十分匹配,并且那里还有一个2. 我们需要改动指数2 / h3以便它和 -5h3相匹配. 最好的方法就是来看看, 如果我们想要求的是



那么一切将会多么美好, 因为该极限就是e.太棒了! - 5h3是匹配的项, 因此, 这就是用 -5h3代替h的经典极限



不幸的是, 我们必须再做一些运算.我们需要将1 /( - 5h3)变为2 / h3.为了实现这一变化, 我们必须用 - 5与之相乘来删除分母中的 - 5,然后再用2与之相乘来修正分子. 总体效果就是我们应该用 -10与之相乘. 这样, 我们得到





9.4.2　指数函数在0附近的行为


我们想要理解的是, 当x非常接近于0时, ex的行为如何.事实上, 由于e0 = 1, 我们知道



当然, 你可以用任意的当x → 0时趋于0的量来替换x, 会得到相同的极限. 例如,



　也一样. 因此,我们可以求



方法是将上式进行如下分解：



　当x → 0时, 两个因子都趋于1, 故整个极限为1 × 1 = 1.现在有一个更难求解的例子：



当x变得非常大时, 1 /x会变得非常接近于0; 故e1 /x非常接近于1并且可被忽略. 你最好的选择就是将以上极限写为



第一个分式趋于1, 使用4.3节的技巧,你可以证明第二个因子趋于2, 故极限是2.

如果你的指数项出现在一个乘积或商当中, 这种方法就会起到很好的作用,但对于如下形式：



很可惜, 它的作用就会丧失.我们想用1替换eh, 这倒没错, 但就是你会得到一个无用的0 /0的情况. 问题是, 我们有一个eh和1的差,当h在0的附近时, 它会变得非常小. 那么我们应该怎么办呢?正如我们在6.5节中看到的, 当哑变量本身在分母上,极限可能是一个伪装的导数. 我们试着设f(x) = ex, 结果f'(x) = ex(正如我们在9.3节中看到的). 在这种情况下, 标准公式



变为



现在, 我们所需要做的就是用0替换x.由于e0 = 1, 我们得到以下有用的事实





你可以再次用任意的很小的量来替换h.例如,



标准匹配技巧的确有效.这实际上和我们在多项式型的极限问题(第4章)、变量很小的三角函数的极限问题(第7章)以及9.4.1节中的极限问题中使用的技巧是一样的.





9.4.3　对数函数在1附近的行为


　现在我们来看看对数函数在1附近的行为如何.事实表明, 其行为和指数函数在0附近的行为十分相似. 我们知道ln(1) = 0, 但是



是什么呢？信不信由你, 这是导数伪装的极限(见6.5节)的另一个例子.正如我们在9.3节中看到的, 设f(x) = ln(x)并且注意f'(x) = 1 / x. 现在等式



变为



对于任意的x. 剩下要做的只是将x =1代入并得到



由于ln(1) = 0,上式简化为





我们可以再次用任意的当h → 0时趋于0的量来替换h, 且极限仍将是1. 例如, 为了求



你必须改动分母, 使它看起来像如下的 -7h2：



这就是我们那个常用的技巧,用一个有用的量(在该例中是 - 7h2)做乘法和除法. 不管怎样,由于那个很小的量 - 7h2匹配, 故第一个分式的极限是1,第二个分式正好化简为 - 7 / 5. 因此, 极限就是 - 7 / 5.





9.4.4　指数函数在∞或- ∞附近的行为


我们想要理解的是, 当x → ∞或x → -∞时, ex的行为如何. 让我们再来看看ex的图像吧, 如图9-2所示.



图　9-2

注意：以上曲线看起来好像要在图像的左侧接触x轴, 但它没有; 请记住, 对于所有的x, ex > 0, 因此, 没有x轴截距.(这是为了解真实情况而不依赖于图形计算器的很好的论证!)不管怎么样,看起来我们至少应该有

　及



　如果用某个其他的底数替换e会怎样呢？例如,我们考虑

　及

为了处理第一个极限, 我们使用等式, 其中A = 2x, 写作



现在, 当x → ∞时, 我们也有xln(2) → ∞,故第一个极限是∞. 至于第二个极限,这一次我们可以使用相同的技巧, 将其写作



当x → ∞时, 我们看到, 故其倒数趋于0. 这样,我们就证明了

　及

以下极限有几个特例：



当r = 1时, 中间的情况显然成立,因为对于所有的x ≥ 0, 1x = 1.我们可以用处理上述2x和(1 / 3)x的极限时相同的方法来证明其他两种情况——就是将rx写作.

这还不是问题的全部. 极限



说明当x变大时, ex变得越来越大(你想要多大就多大). 但是这发生的有多快呢？毕竟,我们也有



x2或 ex,哪一个增长得更快呢？答案是, 当x很大时, ex比x2增长速度快. 毕竟, 当x = 100时, 量x2只是 100 × 100,而



有一百个因子e, 但只有两个因子100,故e100远远大于1002. 当x变得更大时,这种情况仍然成立. 由于ex远远大于x2,当你用x2除以ex时, 你应该得到一个很微小的数.事实上,



直到在第14章看过洛必达法则后,我们才会证明上式. 目前, 我想要指出的是,如果你用x的任意次幂替换x2, 上述极限依然成立.就连x999都不能和ex抗衡. 当x是十亿时,x999是十亿的999次复制相乘的结果, 但ex是e十亿次复制相乘的结果! 尽管e比十亿小很多, 但是当x很大时,在大小上ex会超过x999. 因此, 一般来说,我们有以下原则：

指数函数增长迅速：不管n有多大,

事实上, 对上式进行一些微调, 你可以得到一个更一般的陈述：



例如,



　要知道为什么,我们简单地将分式分成三部分, 每一部分都趋于0,因为指数函数增长迅速.更巧妙的是,



　这里的关键是,当x变大时, 2x3 - 19x2 - 100的行为就像是2x3, 因此,指数函数的确是大的、正的多项式型的部分.2事实上, 我们可以用任意的大于1的底数来替换e. 例如, 我们也有

2如果你真想求证的话, 对于足够大的x, 你必须会写出像2x3 -19x2 - 100 > x3这样巧妙的关系. 毕竟, 如果2x3 - 19x2 -100的行为如2x3, 那么很明显, 它终究会大于x3. 因此,分母大于ex3. 现在, 我们用u替换x3,结果分母就是eu且分子是某个很容易处理的表达式. 最后,我们使用三明治定理.



　另一个变形涉及,e-x就是1 / ex的另一种写法.下面是一个有关的例子：



我们可以将它写成



　这里的极限是0,因为指数函数增长迅速. 现在, 我们考虑一个与之非常相似的极限



这当然涉及了ex在 - ∞附近的行为, 但是, 我们设t = - x, 就可以将情形移至+ ∞上来考虑. 我们可以看到, 当x → ∞时, 我们有t → +∞. 因此



极限又是0, 因为分子是一个多项式(其首项为负, 但这并不要紧). 因此,通过做替换t = - x, 你可以处理当x → -∞时的ex的极限. 这意味着, 现在你必须处理当t → ∞时e-t的极限, 就是将e-t写成1 / et.





9.4.5　对数函数在 ∞ 附近的行为


让我们继续讨论. 来看看当x是一个很大的正数时ln(x)的行为如何. (请记住, 你不能取任何负数的对数, 因此,没有必要研究对数函数在- ∞附近的行为!)我们再来看看y = ln(x)的图像, 如图9-3所示.



图　9-3

此外, 重要的是要注意该曲线绝不会接触y轴,尽管看起来它好像会和y轴接触. 实际上它只是非常非常接近y轴.不管怎样, 这看起来好像是





事实上, 这很容易直接证明. 你认为ln(x)会凑成1 000吗？当然会：ln(e1 000) = 1 000. 同样的技巧适用于任意的数N.我们就取x = eN, 你会发现ln(x) = ln(eN) = N. 因此, ln(x)会变多大是没有极限的, 当x → ∞时, 它趋于∞……但有多快呢？

我们很容易看出其速度相当慢. 正如我们刚刚注意到的, ln(e1 000) = 1 000. 数e1 000是极大的正数(比宇宙中的原子的个数还要大)然而其对数仅为1 000.我们讨论的是简化问题的大小!

更确切地说, 事实表明ln(x)趋于无穷大的速度比x的任意的正幂次都要慢很多,甚至如x0.000 1. 因此, 如果你取ln(x)和x的任意的正幂次的比,那么该比值应该会很小(至少当x非常大时会很小). 用符号表示,我们有

对数增长缓慢：如果0">， 不管a多么小.

正如指数函数的情况,我们不难将该式扩展成一个更一般的形式：



　这适用于任何以b> 1为底的对数函数, 不只是自然对数.(这是因为我们有换底法则.) 例如,



尽管x0.1非常小.

事实上, 一旦我们知道了指数函数增长迅速,那么我们就不应该对对数函数增长缓慢感到惊讶. 毕竟,对数函数和指数函数互为反函数. 更确切地说, 如果你取ln(x) / xa并用et替换x, 那么你会得到



最后一个极限是0,因为分母中的指数函数eat的增长比分子中的多项式t的增长要快很多. 这样,我们就证明了指数函数增长迅速,并自动地引出对数函数增长缓慢这一事实.





9.4.6　对数函数在0附近的行为


有人很想写ln(0) = - ∞, 但是这是不正确的,因为ln(0)是无定义的. 另一方面, 上述的y = ln(x)的图像暗示了





　在这里, 你需要使用右极限, 由于ln(x)在x < 0上没有定义. 尽管如此, 我们仍需要说更多的. 当x → 0+时, ln(x)当然趋于 - ∞,但是有多快呢？ 例如,我们考虑极限



如果你只是将0代入上式, 这根本不起作用, 因为ln(0)不存在. 当x是一个比0稍大一点的数时,量x很小而ln(x)是一个很大的负数.当你用一个很大的数和一个很小的数相乘时会怎样呢？任何情况都可能发生,这取决于那些数有多么小和多么大.

这里有一个求解上述问题的方法了. 我们用1 / t替换x. 那么, 当x → 0+时, 我们可以看到t → ∞. 因此, 我们有



当然, ln(1 / t)正是ln(1) - ln(t),由于ln(1) = 0, 它等于 - ln(t).因此我们得到



其中, 由于对数增长缓慢, 故极限是0.

用1 / t替换x的这一技巧可以将0附近的行为转换为∞附近的行为, 这是因为ln(1 / t) = - ln(t). 你可以使用它来证明下列原理,上述的例子就是该原理的一个特例：

对数函数在0上“增长”缓慢：不管a有多小, 如果 0, \lim_{x\to0^+}x^a\ln(x)=0">

(我把“增长”加上引号, 是因为当x → 0+时, ln(x)实际上是向下增长到 - ∞ .)你可以再次用多项式型部分来替换xa, 只要当x → 0+时,它变得非常小就可以, 并且对于任意的其他的底数b > 1,我们可以用“logb”替换“ln”. (即, 不只是底数e).





9.5　对数函数求导


　处理像f(x)g(x)这样底数和指数均为x的函数的导数问题时,对数函数求导是一个有用的技巧. 毕竟, 用我们已经讲过的知识,你到底会如何求解以下导数呢?



没有一个法则适用于上述导数的求解. 尽管如此,我们有些很好的对数法则, 他们会简化指数. 如果我们令y = xsin(x), 根据9.1.4节的对数法则#5, 那么



现在, 让我们对等号两边关于x(作隐函数)求导：



　我们先来看看右边的部分.它就是一个x的函数且需要用乘积法则来求解;你应该检验一下求导结果是cos(x)ln(x)+ sin(x) / x. 现在我们来看看左边的部分. 为了对ln(y)关于x求导(不是关于y!),我们应该使用链式求导法则. 设u = ln(y), 结果. 我们需要求出;根据链式求导法则,



因此, 对方程ln(y) =sin(x)ln(x)进行隐函数求导得到



现在我们只需要用y和等号两边相乘, 然后用xsin(x)替换y：



这就是我们要找的答案了.(根据链式求导法则, 我们还可以用另外一种方法来解此题.不使用变量y, 我们可以只使用公式来写



　现在,由你来使用乘积法则和链式求导法则对右侧关于x求导吧. 当你完成时,你应该用xsin(x)来替换esin(x)ln(x)并检验你是否得到和原来一样的答案.)

　让我们来回顾一下主要的技巧吧.假设, 你想要关于x对以下函数求导



其中, 底数f和指数g都含有变量x.下面就是你需要做的：

1. 设y是你想要求导的x的函数. 对等号两边取(自然)对数.指数g下降到右侧的位置, 这样你会得到



2. 对等号两边关于x作隐函数求导.右侧常常会使用到乘积法则和链式求导法则(至少).左侧的结果总是. 因此, 你会得到

(讨厌的 x)

3. 用y和等式两边相乘会得到单独的这一项,然后, 用原始的表达式f(x)g(x)替换y, 你就完成了求解.

　这里还有另外一个例子：



是什么呢？根据第一步, 我们设y = (1 + x2)1 /x3, 然后, 对等式两边取对数, 这样会使指数下降, 我们得到



第二步是对等式两边关于x作隐函数求导.如往常一样, 左侧变为, 但是, 我们必须对右侧使用商法则. 首先,使用链式求导法则对z = ln(1 + x2)求导：如果u =1 + x2, 那么, z = ln(u), 故



现在,你可以使用商法则. 你应该检验一下, 当你对上述方程ln(y) = ln(1 + x2) / x3作隐函数求导时,你是否得到(简化之后)



最后, 用y和等式两边相乘, 并用替换y会得到



这样我们就完成了求解.

　甚至当底数和指数都不是x的函数时, 对数求导仍然会非常方便使用的. 如果你的函数真的很繁杂并涉及很多乘积和幂函数(像x2)与指数函数(像ex的商, 你或许想要尝试用对数求导了. 例如,

如果 是什么?



我准是在开玩笑呢,对吗？你如何对像这样糟糕的表达式求导呢？使用对数求导就可以.对等式两边取自然对数,你会发现右侧变得更容易处理了(只要你还记得对数法则),如：



在继续阅读之前, 确保你理解这些对数的操作. 不管怎样,现在我们可以对该表达式关于x作隐函数求导了：



如往常一样, 左侧是, 因此, 让我们来逐项地看看右侧.

第一项是100ln(x2 - 3).这正是一个简单的链式求导法则的练习, 看看其导数就是100 × 2x /(x2 - 3), 这当然是200x /(x2 - 3).



第二项是sec(x)ln(3).在你使用乘积法则之前, 请记住ln(3)是一个常数,因此, 事实上, 你可以只求sec(x)的导数, 然后和ln(3)相乘得到ln(3)sec(x)tan(x).



第三项是 - ln(2). 它是一个常数,故其导数就是0.



第四项是 - 5ln(x). 其导数为 - 5 / x.



第五项是 - 9ln(log7(x) + cot(x)). 我称之为z, 我们需要使用链式求导法则.尽管你必须能够自己求出, 我还是将细节列出来. 令u = log7(x) + cot(x), 故z = - 9ln(u). 那么我们有





综合起来会得到



现在, 用y与之相乘会得到



最后, 用原始的(可怕的)表达式替换y会得到



这看起来很不舒服, 但是你想象一下, 如果不使用对数求导,情况将会怎样!

x 的导数

现在终于可以证明我们一直认为是理所当然的事情了：





对于任意的数a, 不只是我们之前看到的整数. 我们假设x > 0.现在来使用对数求导：设y = xa, 结果ln(y) = a ln(x). 如果你对两边作隐函数求导, 你会得到



现在,我们用y与之相乘并用xa替换y：



这就是我们想要的, 至少是当x > 0时想要的. 当x ≤ 0时, 我们有一个小问题. 例如,你甚至不可能求( - 1)1 / 2,因为这是一个负数的平方根. 那么, 究竟是什么呢？事实上, 如果不使用复数(毕竟,直到第28章我们才会学到),只有当a是一个带有一个奇分母(在删除公因子之后)的有理数, 对于x < 0, xa才有意义. 例如, 对于负数x, x5 / 3有意义,因为你总是可以求一个立方根——这没有问题, 因为3是一个奇数.对于x < 0xa有意义的情况, 事实表明,它或者是x的偶函数或者是x的奇函数. 你可以使用其导数仍是axa -1的事实.

　这里有一些使用公式的简单的例子.如果定义域是(0, ∞), 那么关于x的导数是什么呢？xπ又怎样呢？我们使用公式可以证明,对于x > 0,

　及

这和我们之前所做的没什么实际的区别,~只是我们现在可以处理非整数的指数了.





9.6　指数的增长和衰退


我们已经看到了, 带有连续复利的银行账户的增长是指数型的. 尽管如此,我们不需要用这么多的人造设置来求指数增长,在自然现象中也会出现指数增长. 例如, 在一定的情况下, 动物的总数,如兔子(和人类!)呈指数增长. 还有指数衰退, 其中,一个量以指数的方式变得越来越小(我们很快就能看到这意味着什么了).这发生在放射性衰退中,这使得科学家们能够找出古代的人造物品、化石或岩石的年龄.

以下就是基本思想. 假设, y = ekx. 那么,正如我们在9.3.1节中的开始部分看到的一样, . 我们可以将等式右边写作ky, 因为y = ekx. 即,



这是一个有关微分方程的例子. 毕竟, 它是一个涉及导数的方程.我们将在第30章中看到更多的微分方程, 但现在,就让我们把精力集中在这一个上吧.其他的什么函数能够满足上述方程呢？我们知道y = ekx满足,但一定还有其他的函数也满足. 例如, 如果y = 2ekx,那么, 其结果再次为ky.更一般地来说, 如果, 那么, 这也等于ky. 事实表明, 这是你可以得到的唯一的途径：

如果 , 那么 对于某个常数 A.



我们将在30.2节中学到这样说的原因. 同时,让我们再来仔细看看微分方程吧.首先我们要做的是将变量x变为t, 结果是我们看到



这意味着, y的变化率和ky的相同.这太有趣了! 一个量变化的速率取决于你拥有的这个量的大小.如果你的量越大, 那么它就会增长得越快(假设k > 0).在人口增长的情况下这是有意义的：你的兔子越多, 它们可以繁殖得越多.如果你有两倍的兔子, 那么在任意给定的时间周期中,它们也会产生两倍的兔子. 数k被称为增长常数,它首先控制兔子繁殖的速度有多快. 它们越野蛮, k越高!





9.6.1　指数增长


假设我们有一个指数增长的总数. 用符号表示, 设P(或P(t), 如果你喜欢)是在时刻t时的总体, 并设k是增长常数.P的微分方程为



这和上述框中的微分方程是一样的,除了一些符号的改变外. 我们有P而不是y; 我们有t而不是x.这不要紧, 我们善于适应环境; 我们就在解中做同样的改变. 结果是对于某个常数A, . 现在, 当t = 0时, 我们有, 因为e0 = 1.这意味着, A是初始的总数, 即, 在时刻0时的总体. 惯例上,我们也要重新标示变量. 我们写P0来代替A,它表示在时刻0时的总体. 总之, 我们已经求出

指数增长方程：



请记住, P0是初始的总数,k是增长常数.

　此公式很容易应用到实际中,只要你知道指数和对数法则(见上述的9.1.1节和9.1.4节). 例如,如果你知道三年前兔子的总数是1 000只, 而现在增长至64 000只,那么, 从现在开始, 一年之后总数会怎样变化呢？此外,总数从1 000增长至400 000需要多长时间呢？

好吧, 我们有P0 = 1 000, 因为这是初始的总数.故上述的框中方程变为P(t) = 1 000ekt.问题是, 我们不知道k是什么. 而我们知道的是, 当t = 3时, P =64 000, 因此, 我们将其代入：



这意味着, e3k = 64.我们对两边取对数得到3k = ln(64), 故. 事实上, 如果你写ln(64) = ln(26) = 6ln(2),那么你可以将其化简为k = 2ln(2). 这意味着,对于任意的时刻t,



现在, 我们可以求解该问题了.对于第一部分, 我们想要知道从现在开始的一年中会发生什么情况.这事实上是从初始时刻开始的4年时间, 故设t = 4.我们得到



现在, 我们有一个小窍门：将8ln(2)写作ln(28) = ln(256), 故



这里我们使用了重要的公式, 对于任意的数A > 0, . 结论是, 从现在开始之后的一年,总数将变为256 000. 现在, 我们来处理问题的第二部分.我们想要知道需要多长时间总数会增至400 000, 故设P = 400 000,得到



这变为. 为了求解这一方程, 我们对等式两边取对数, 得到2ln(2)t = ln(400), 这意味着



这就是总体从1 000增至400 000所需年数, 但这并不是很直观的.你可以使用计算器算出一个近似值. 但假设你手边没有的话,你就需要知道ln(5)近似为1.6,而ln(2)近似为0.7. 我们先写出400 = 202, 这样ln(400) = ln(202) = 2ln(20). 然而,我们甚至可以做得更好, 即ln(20) = ln(4 × 5) = ln(4) + ln(5)= 2ln(2) + ln(5). 综上所述,我们得到



使用近似值, 得到



因此,尽管需要4年总数才能达到256 000,但只需要大约再有七分之二年——大概3个半月——来达到400 000的总数.这就是指数增长的力量……





9.6.2　指数衰退


让我们反转一切来看看指数衰退吧. 为了设置场景, 我来告诉你,我们有特定的原子, 它们是放射性的. 它们像小的定时炸弹：一段时间后,它们拆分成不同的原子, 同时释放出能量. 唯一的问题是,你绝不会知道它们何时拆分(我们不说“拆分”而说“衰退”).你所知道的就是在一个给定的时间上,存在衰退将会发生的一个特定的概率.

例如, 你或许有一种特定类型的原子,它在任意的7-年的周期内衰退的概率是50%. 因此,如果在一个盒子里你有这些原子当中的一个, 关上盒子,并在7年后打开它, 那么它已经衰退的概率就是50 - 50. 当然,看到一个单独的原子相当难! 因此, 我们假设, 更现实一点,你有一万亿个原子(顺便说, 这仍是原料中的极小的一点.).你将它们放入盒子, 7年后回来. 你期待发现什么？好吧,大概有一半的原子应该已经衰退了, 而另一半仍是完好的. 因此,你应该有大概一万亿的一半的原始的原子. 再过7年,你又返回将是什么样的呢？一半的剩余的原始的原子会仍然完好,即留给你的是一万亿的四分之一的原始的原子. 每隔7年,你失去所剩样本的一半.

因此, 让我们试着写出一个方程来对该问题建模. 如果P(t)是原子在时刻t的数量(总数？), 那么我断言,对于某个常数k,



这说的是,P的变化率是P的负倍数. 即 P是以一个和P成比例的速率衰退的.你拥有的原子数越多, 它们衰退得就越快.这和上述的例子是一致的：在第一个7年中,我们失去了一万亿原子中的一半, 而在下一个7年中,我们只失去了一万亿的四分之一的原子, 再过7年,我们只会失去一万亿的八分之一的原子. 我们拥有的越多,失去的也就越多. 不管怎样, 上述微分问题的解是



其中, P0是原子的原始数量(在t =0时). 这和上一节中指数增长的方程是一样的, 除了我们用一个负的常数- k替换了增长常数k, 它被称为衰退常数.

在上例中, 我们知道对于任何的原子的样本, 需要7年时间数量才会减半.这个时间长度被称为原子(或原料)的半衰期.在上述方程中, 这意味着, 如果你开始有P0个原子,那么7年后, 你会有个原子. 因此, 设t =7且上式中, 我们有



现在, 我们从等号两边删除因子P0并对两边取对数, 得到



由于, 上述方程变为



这意味着, 在这种情况下,



现在, 我们将以上情况一般化. 假设, 你有一些其他的放射性原料,它们的半衰期是t1 / 2年. 这意味着,任何大小的原料的样本的一半会在t1 / 2年后衰退.但并不是说整个样本会在两倍的那么多年后衰退! 不管怎样,依据和上一段中相同的理由, 我们可以证明. 总之,

对于带有半衰期t1 / 2的放射性的衰退, 其中 .



　例如,如果原料的半衰期仍是7年, 开始时你有50磅原料,10年后你会有多少呢?并且需要多久你的原料会减少为1磅呢？我们知道t1 / 2 = 7, 故k= ln(2) / 7, 这正如我们之前所见. 由于P0 =50(单位：磅), 衰退方程变为



故当t = 10时, 我们有



即, 我们的原料缩减为磅. 如果我们使用上面的近似值, 那么我们看到我们有大约50e- 1磅,我们可以继续将它近似为大概18.4磅.

至于问题的第二部分, 现在我们需要求出需要多久我们的原料会缩减为1磅,故在上面P(t)的方程中设P(t) = 1,我们得到



两边同除以50并取对数, 得



由于ln(1 / 50) = -ln(50), 我们有 - 7ln(50) = -t ln(2). 即,



我们可以使用之前的近似值和对此进行估算. 我们写ln(50) = ln(2 × 5 × 5) = ln(2) + 2ln(5), 看到



其结果是39年. 因此, 样本大概需要39年从50磅衰退到1磅.顺便说的是,39年比个半衰期(由于一个半衰期是7年)多一点.因此, 如果你有50磅的不同的原料, 其半衰期为10年, 那么,该原料将需要比55年多一点的时间衰退到1磅. (实际的数量是10ln(50) / ln(2)年,这非常接近于年.)





9.7　双曲函数


我们改变一下行径, 来探讨一下所谓的双曲函数吧. 事实上, 这些就是伪装的指数函数,但它们在很多方面都和三角函数非常相似. 我们不会使用太多的双曲函数,但它们偶尔会出现, 因此最好还是熟悉一下它们吧.

我们先来定义双曲余弦函数和双曲正弦函数：





我们不需要三角形! 毕竟,这根本不是三角学.3这些函数的行为有些像普通的函数, 但不完全是. 例如, 如果你平方cos h(x)和sin h(x), 你会发现

3事实上, 我们有一个几何的分支, 称为双曲几何学, 其中, 三角形有古怪的性质,这就引出了双曲函数.



及



(我们使用了exe-x = 1的事实.) 不管怎样, 我们取这两个量的差：



这样我们就证明了, 对于任意的x,





这和原来的三角恒等式不太一样——减号造成了所有的差异.(事实上,x2 - y2 = 1是一个双曲方程.)

微积分的性质如何呢？我们来对y = sin h(x)求导.我们需要知道, e-x的导数是- e-x：



因此, 双曲正弦的导数就是双曲余弦.这就好像原来的常规正弦和余弦的情况. 另一方面,



如果这些是普通的三角函数的话, 那么,其导数将是负的双曲正弦, 但是我们在这里没有负号. 不管怎样,我们证明了

　及



　现在,我们来看看这些函数的图像吧. 首先, 你应该试着让自己相信, cos h(x)是x的偶函数, 而y = sin h(x)是x的奇函数.(只需将 -x代入看看会发生什么就一目了然了.) 此外, cos h(0)= 1且sin h(0) = 0(请检验). 最后, 我们注意到



ex趋于 ∞, 而e-x趋于 0.全部的效果就是极限是 ∞. 同理适用于sin h(x), 因此, 其图像看起来一定如图9-4.



图　9-4

当然, 你可以用sin h(x) / cos h(x)来定义tan h(x), 还有倒数sec h(x)、csc h(x)及cot h(x).我们可以通过用适当的指数函数做替换对双曲正割、双曲余割和双曲余切函数进行求导.例如,



你可以使用链式求导法则或乘积法则对它求导.我们还有联系这些函数的恒等式, 最重要的一个就是



　这可以直接从恒等式cos h2(x) - sin h2(x) = 1中推出,两边同除以cos h2(x). 现在,我要列出其他双曲函数的导数并展示它们的图像了——我留给你的是检验所有的导数并检验至少一个图像是有意义的.首先是导数：





现在来看看图9-5：



图　9-5

由函数的定义, 你可以看到,除了双曲余弦和双曲正割是偶函数外,所有的双曲三角函数都是奇函数. 这和原来常规的三角函数的情况相同!此外, y = tan h(x)和y = cot h(x)都在y = 1和y = - 1处有水平渐近线, 而y = sec h(x)和y = csc h(x)在y =0处都有一条水平渐近线.





