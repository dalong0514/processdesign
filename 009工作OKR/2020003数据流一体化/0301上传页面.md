# 数据上传进数据库

## CAD 数据字段

### 房间参数

房间编号：room_id

房间名称：room_name

房间面积：room_area

计算高度：cal_height

室压：room_pressure

夏季室内温度：summary_temp

夏季室内相对湿度：summary_rehumidity

冬季室内温度：winter_temp

冬季室内相对湿度：winter__rehumidity

## 01. 上传文件

3『[关于 laravel 系统自带的文件上传功能](https://blog.csdn.net/qq_27516777/article/details/79723057)

进入文件 dataflow -> config -> filesystems.php，其中有一个 disk 的配置。

```php
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default filesystem disk that should be used
    | by the framework. The "local" disk, as well as a variety of cloud
    | based disks are available to your application. Just store away!
    |
    */

    'default' => env('FILESYSTEM_DRIVER', 'local'),

    /*
    |--------------------------------------------------------------------------
    | Default Cloud Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | Many applications store files both locally and in the cloud. For this
    | reason, you may specify a default "cloud" driver here. This driver
    | will be bound as the Cloud disk implementation in the container.
    |
    */

    'cloud' => env('FILESYSTEM_CLOUD', 's3'),

    /*
    |--------------------------------------------------------------------------
    | Filesystem Disks
    |--------------------------------------------------------------------------
    |
    | Here you may configure as many filesystem "disks" as you wish, and you
    | may even configure multiple disks of the same driver. Defaults have
    | been setup for each driver as an example of the required options.
    |
    | Supported Drivers: "local", "ftp", "sftp", "s3"
    |
    */

    'disks' => [

        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION'),
            'bucket' => env('AWS_BUCKET'),
            'url' => env('AWS_URL'),
        ],

    ],

];

```

1、disk 配置项的总调用，在后面会用到的。可以把它当做一个 public 的调用方法这样就很好理解了。

2、local 代表的是其中的一个小的配置项，因为或许一个项目中，要有很多不同的存储方式或者存储位置，local，public，s3 都是表示不同的存储方式。

3、driver 表示的是存储位置，像 local 表示的就是存储在本地项目中。s3 是存储在亚马逊的磁盘位置，或许还有很多，到时候我们就可以按照这三个的 demo 模式继续的创建。一般都是存储在项目本身。

4、root 表示的是文件存储的位置。‘app/public’ 表示的就是文件存储在 dataflow->storage->app->public 下面。app/public 是可以随意的改变的。正常的就像 local 的两个配置就可以了。

』

还是决定通过控制器来显示页面，新建一个上传控制器：

    php artisan make:controller ImportController

路由设置：

```php
Route::get('/upload', 'ImportController@show');

// 感觉这里的 post 有更好的声明方式，待研究
Route::post('/upload', 'ImportController@upload');
```

前端上传页面的代码（）：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="container">
        <form class="form-horizontal" method="POST" action="" enctype="multipart/form-data">
            {{ csrf_field() }}           
            <input id="file" type="file" class="form-control" name="source" required>    
            <button type="submit" class="btn btn-primary">确定上传</button>
        </form>
    </div>
</body>
</html>
```

控制器里的代码：

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class ImportController extends Controller
{
    public function show() {
        return view('import');
    }

    // 文件上传
    public function upload(Request $request) {
        $fileCharater = $request->file('source');
        // 先验证
        if ($fileCharater->isValid()) {
            // 获取扩展名
            $ext = $fileCharater->getClientOriginalExtension();
            // 获取文件绝对路径
            $path = $fileCharater->getRealPath();
            // 定义存入的文件名
            $filename = date('Y-m-d-h-i-s') . '.' . $ext;
            // 存储文件
            Storage::disk('public')->put($filename, file_get_contents($path));
        }
        return view('importresult');
        // return back();  // 返回到上一个页面
    }
}

```

3『

使用 Illuminate\Http\Request 实例中的 file 方法获取上传的文件。file 方法返回的对象是 Symfony\Component\HttpFoundation\File\UploadedFile 类的实例，该类继承了 PHP 的 SplFileInfo 类，并提供了许多和文件交互的方法；可以使用请求的 hasFile 方法确认上传的文件是否存在：

```php
if ($request->hasFile('source')) {
    //
}
```

可以通过 isValid 方法验证上传的文件是否有效：

```php
if ($request->file('source')->isValid()) {
    //
}
```

』

## 02. 用 Laravel-Excel 实现

[在 Laravel 5 中使用 Laravel Excel 实现 Excel/CSV 文件导入导出功能](https://xueyuanjun.com/post/2024.html)

[使用 Laravel-Excel 进行 CSV/EXCEL 文件读写](http://www.ptbird.cn/laravel-excel-csv.html)

上面的 2 篇都是低版本的，没跑通，反而是通过官方文档跑通了输出文件，但文章里的有些细节可以借鉴。

先安装：

    composer require maatwebsite/excel

生成配置文件：

    php artisan vendor:publish --provider="Maatwebsite\Excel\ExcelServiceProvider"

### 1. 路由

导入导出的路由先设置好：

```ja
Route::get('/excel/import', 'ImportController@import');
Route::get('/excel/export', 'ImportController@export');
```

### 2. 文件导出

先构建导出文件夹的目录结构：

    php artisan make:export UsersExport --model=User

这就新建了文件夹 app/Exports 以及里面的文件 UsersExport.php。接着在 app/Exports 文件夹里新建一个类文件 InvoicesExport.php，可以采用数组的形式导出：

```php
<?php
namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;
use Maatwebsite\Excel\Concerns\FromArray;

class InvoicesExport implements FromArray
{
    public function array(): array
    {
        $cellData = [
            ['学号','姓名','成绩'],
            ['10001','AAAAA','99'],
            ['10002','BBBBB','92'],
            ['10003','CCCCC','95'],
            ['10004','DDDDD','89'],
            ['10005','EEEEE','96'],
            ['10005','EEEEE','98'],
        ];
        return $cellData;
    }
}
```

接着进控制器写导出的方法：

```php
// 文件导出
public function export() {
    return Excel::download(new InvoicesExport, 'invoices.xlsx');
}
```

上面的导出是弹出窗口自己选择存储的位置，同时可以修改文件名称。也可以直接存放进磁盘里，可以再增加一个存储的方法：

```php
// 文件导出
public function export() {
    // return Excel::download(new InvoicesExport, 'invoices.xlsx');
    $this->storeExcel();
}

// 导出的文件存储
public function storeExcel() {
    // 默认位置
    Excel::store(new InvoicesExport(2018), 'invoices.xlsx');
}
```

发现存放的默认位置是 /storage/app，如果想存进 /storage/app/public，进文件系统配置文件里修改：

```php
'local' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
        ],
```

### 3. 文件读取

先构建导入文件夹的目录结构：

    php artisan make:import DataImport --model=User

这里可以去掉后面的模型文件指定：

    php artisan make:import DataImport

这就新建了文件夹 app/Imports 以及里面的文件 DataImport.php。

```php
<?php

namespace App\Imports;

use App\User;
use Maatwebsite\Excel\Concerns\ToCollection;
use Illuminate\Support\Collection;

class DataImport implements ToCollection
{
    /**
    * @param array $row
    *
    * @return \Illuminate\Database\Eloquent\Model|null
    */
    public function collection(Collection $rows) {
        foreach ($rows as $row) {
            User::created([
                'name' => $row[0],
            ]);
        }
    }
}
```

1『

后来发现可以在自己建的模型文件里创建数据对象，而且写数据时 row 不需要加下标。

新建模型文件：

```
php artisan make:model Models/NsVentilation
```

```php
public function collection(Collection $rows) {
    // 模型文件里创建数据对象
    foreach ($rows as $row) {
        AerationCalculate::created([
            'cadata' => $row,
        ]);
    }
}
```

甚至不需要遍历：

```php
AerationCalculate::created([
            'cadata' => $rows,
        ]);
```

具体到时为什么还不清楚，直觉上如果用 arrary 而不是 collection 的话，就需要遍历，待验证。（2020-04-25）

获取信息：Eloquent 模型提供的 create 方法，通过传入一个关联数组来新建一个用户对象。里面给的实现是：

```php
User::create(['name'=> 'Summer', 'email'=>'summer@example.com','password'=>bcrypt('password')])
```

那么联想下，\$rows 已经是一个数组对象了，直接传进去好了，经试验可行。

```php
AerationCalculate::created($rows);
```

只是目前这个数组对象的「键」都是数字，得想办法转为了特定的字符串。已完成，详见下面的数据清洗。

』

接着在控制器里添加相应的方法：

```php
// 导入文件数据
public function import() 
{
    $collection = Excel::toCollection(new DataImport, 'invoices.xlsx');
    var_dump($collection);
    echo $collection;
    // Excel::import(new DataImport, 'invoices.xlsx');
}
```

报错：Class App\Imports\DataImport contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (Maatwebsite\Excel\Concerns\ToCollection::collection

[php - Cannot understand how WithMultipleSheets working in Laravel Excel 3.1 - Stack Overflow](https://stackoverflow.com/questions/59339108/cannot-understand-how-withmultiplesheets-working-in-laravel-excel-3-1)

找了半天发现函数名写错了。

错误的：

```
public function model(Collection $rows)
```

正确的：

```
public function collection(Collection $rows)
```

接着实现了从上传的文件里直接提取数据，不用先存磁盘。后续的思路也是不存网盘，直接存入数据库。

```php
// 直接才能上传的文件里抽取数据
public function upload(Request $request) {
    $fileCharater = $request->file('source');
    
    // 先验证
    if ($fileCharater->isValid()) {
        // 直接读取
        $collection = Excel::toArray(new DataImport, $fileCharater);
        // $collection = Excel::toCollection(new DataImport, $fileCharater);
        var_dump($collection);
        // echo $collection;
    }
}
```

### 4. 数据清洗

```php
// 更新数组的键名
public function replace_key($array, $oldkey, $newkey) {
    $keys = array_keys($array);
    // 考虑要替换的键名不存在的情况
    if (false === array_search($oldkey, $keys)) {
        throw new \Exception('Key ' . $oldkey . ' does not exit');
    } else {
        $keys[$oldkey] = $newkey;
        return array_combine($keys, array_values($array));
    }
}
// 更新 cad 数组键名
public function replace_keys($array, $keyarray) {
    $keys = array_keys($keyarray);
    foreach ($keyarray as $key => $value) {
        $keys[$key] = $value;
    }
    return array_combine($keys, array_values($array));
}
```

## 03. 写入数据库

1、新建迁移配置文件：

```
php artisan make:migration create_ns_ventilation_table
```

2、配置该文件：

```php
    public function up()
    {
        Schema::create('ns_ventilation', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
            // cad data
            $table->string('room_id')->nullable();
            $table->string('class')->nullable();
            $table->string('equipname')->nullable();
            $table->string('material')->nullable();
            $table->string('posnum')->nullable();
            $table->string('symbol')->nullable();
            $table->string('tpye')->nullable();
            $table->integer('num')->nullable();
        });
    }
```

3、迁移：

```
php artisan migrate
```

此时进数据库里即可看见新迁移来的数据库表（空的）。

4、写数据进数据路。

参考了「2020121Full-Stack-Vuejs2-R01.md->4.8.2 Loading the mock data」里的知识，直接掉门面 Facades 里的 DB 类里的写数据方法。

```php
use Illuminate\Support\Facades\DB;

DB::table('ns_ventilation')->insert($cadata);
```

5、删除表内所有行信息的 sql 命令：

```
DELETE FROM table_name

// 或者
DELETE * FROM table_name
```

## 04. 文件上传的前端实现

原始方法如下：

```html
<body>
    <div class="container">
        <form class="form-horizontal" method="POST" action="" enctype="multipart/form-data">
            {{ csrf_field() }}           
            <input id="file" type="file" class="form-control" name="source" required>    
            <button type="submit" class="btn btn-primary">确定上传</button>
        </form>
    </div>
</body>
```

做成 vue 的单文件，详见后面的源码。

利用 axios、FormData 以数据流的形式实现，折腾了半天有点感觉了，但还没实现。

[FormData 对象的使用 - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects)

```
<template>
    <el-upload
    class="upload-demo"
    drag
    action=""
    :data="csrf_token"
    :http-request="upLoad"
    multiple>
    <i class="el-icon-upload"></i>
    <div class="el-upload__text">将文件拖到此处，或<em>点击上传</em></div>
    <div class="el-upload__tip" slot="tip">只能上传jpg/png文件，且不超过500kb</div>
    </el-upload>
</template>

<script>
    import axios from 'axios'
    export default {
        data() {
            return {
                // csrf_token: window.csrf_token,
                csrf_token: {_token: window.csrf_token},
            };
        },
        methods: {
            upLoad() {
                let formData = new window.FormData();
                formData.append('source', document.querySelector('input[type=file]').files[0]);
                let options = {  // 设置axios的参数
                    url: '',
                    data: formData,
                    method: 'post',
                    headers: { 
                    'Content-Type': 'multipart/form-data',
                    }
                }
                axios(options).then((res) => {}) // 发送请求
            }
        }
    }
</script>
```

问题记录：

1、单文件里的条件渲染，不能用常规的「:vi-if」，需要直接「v-if」，比如「v-if="status"」。

2、条件渲染部分内容时报错：

Form submission canceled because the form is not connected

最后定位到将 button 的属性 type 从「primar」改为「text」可以解决该问题，原理目前不清楚。（2020-05-13）

## 表格展示

components > Pagination 

directive > waves

utils > scroll-to

## 代码

### 1. 控制器代码

2020-05-01

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use App\Exports\UsersExport;
use App\Exports\InvoicesExport;
use App\Imports\UsersImport;
use App\Imports\DataImport;
use League\Fractal\Resource\Item;
use Maatwebsite\Excel\Facades\Excel;
use Illuminate\Support\Facades\DB;

class ImportController extends Controller
{
    public function show() {
        return view('import');
    }

    // 文件上传
    // public function upload(Request $request) {
    //     $fileCharater = $request->file('source');
    //     // 先验证
    //     if ($fileCharater->isValid()) {
    //         // 获取扩展名
    //         $ext = $fileCharater->getClientOriginalExtension();
    //         // 获取文件绝对路径
    //         $path = $fileCharater->getRealPath();
    //         // 定义存入的文件名
    //         $filename = date('Y-m-d-h-i-s') . '.' . $ext;
    //         // 存储文件
    //         Storage::disk('public')->put($filename, file_get_contents($path));
    //     }
    //     return view('importresult');
    //     // return back();  // 返回到上一个页面
    // }

    // 文件导出
    public function export() {
        // return Excel::download(new InvoicesExport, 'invoices.xlsx');
        $this->storeExcel();
    }

    // 导出的文件存储
    public function storeExcel() {
        // 默认位置
        Excel::store(new InvoicesExport(2018), 'invoices.xlsx');
    }

    // 导入文件数据
    public function import() 
    {
        $collection = Excel::toCollection(new DataImport, 'invoices.xlsx');
        var_dump($collection);
        echo $collection;
        // Excel::import(new DataImport, 'invoices.xlsx');
    }

    // 直接从上传的文件里抽取数据
    public function upload(Request $request) {
        $fileCharater = $request->file('source');
        // 先验证
        if ($fileCharater->isValid()) {
            // 直接读取
            $collection = Excel::toArray(new DataImport, $fileCharater);
            // $collection = Excel::toCollection(new DataImport, $fileCharater);
            $data = $collection[0];
            $cadata = [];
            $keyindex = $collection[0][0];
            $keyindex = array_map('strtolower', $keyindex);    // 转小写                
            foreach ($data as $item) {
                array_push($cadata, $this->replace_keys($item, $keyindex));
            }
            array_shift($cadata);    // 剔除首个数据
            // DB::table('ns_ventilation')->insert($cadata);   // 写入数据库
            // var_dump($cadata);
            return view('cadconfirm', ['model' => $cadata]);
        }
    }

    // 更新 cad 数组键名
    public function replace_keys($array, $keyarray) {
        $keys = array_keys($keyarray);
        foreach ($keyarray as $key => $value) {
            $keys[$key] = $value;
        }
        return array_combine($keys, array_values($array));
    }
}

```

### 2. UpLoad.vue

2020-05-13

```html
<template>
<div class="uploadbox">
    <form class="uploadform" method="POST" action="" enctype="multipart/form-data">
        <input id="file" type="file" class="selectfile" name="source" required>    
        <input type="hidden" name="_token" :value="csrf_token">
        <el-button type="primary" native-type="submit" @click="open" class="upbutton">
            加载数据</el-button> 
    </form>
    <router-link :to="{name:'cadconfirm'}">
        <el-button type="primary">确认数据</el-button>
    </router-link>
</div>
</template>

<script>
    export default {
        data() {
            return {
                csrf_token: window.csrf_token,
                status: true,
            };
        },
        methods: {
            changestatus: function() {
                this.status =false;    // 通过条件渲染隐藏按钮待实现（2020-05-13）
            },
            open() {
                this.$alert('上传成功', {
                confirmButtonText: '确定',
                callback: action => {
                    this.$message({
                    type: 'info',
                    message: `action: ${ action }`
                    });
                }
                });
            }
        }
    }
</script>

<style scoped>
    .uploadbox {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .uploadform {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding-bottom: 100px;
    }

    .selectfile {
        width: 200px;
        height: 20px;
        padding-top: 100px;
    }

    .upbutton {
        margin: 100px;
    }
</style>
```