# 0000开发心得

## 01. 感悟

### 0101. 你所看到的可能与事实完全不同

1、小程序里实现的表格实际上是通过 flex 布局，一个个方块拼接的，边缘 border 设置的实体线。只是视觉上像表格。

2、CAD 数据确认后提交入库，用户看到的是在确认后提交入库，实际后端是，在工艺确认数据数据的环节上就已经入库了。

## 02. 问题记录

### 01

数据更新后，选择框下拉无法显示更新的数据。

是 Vue 自身的问题，官方文档里有这么一句：

注意事项：由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。深入响应式原理中有相关的讨论。

[列表渲染 — Vue.js](https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B)

[深入响应式原理 — Vue.js](https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)

因为更新的数据时后加到已经渲染后的数组里的，vue 监测不到新增的。按文档里的 set() 方法，还是没有解决。最后想的办法，是在后端里先增加好前端需要添加的字段（用空字符），先占位，这样的话，更新数据是改了数组里的值，vue 可以监测到重新渲染。（2020-06-23）

### 02

从房间模型链接不到设备模型那边。

```php
// 无效
$equipments = $this->model->equipment;
```

经对比物性模型那边的链接，发现需要在 RoomModel 里加上：

```php
    public function monomer()
    {
        return $this->hasOne(MonomerModel::class, 'id', 'monomer_id');
    }

    public function substance()
    {
        return $this->hasMany(SubstanceModel::class, 'room_id', 'id');
    }

    // 新增
    public function equipment()
    {
        return $this->hasMany(EquipmentModel::class, 'room_id', 'id');
    }
```

EquipmentModel 代码：

```php
    public function room()
    {
        return $this->hasOne(RoomModel::class, 'id', 'room_id');
    }
```

备注：上面的代码后来发现要改成如下，否则链接过去只能获取一个设备的数据，即使表里有多个设备。目前原理还没弄清楚。（2020-06-23）

```
public function room()
{
    return $this->hasMany(RoomModel::class, 'id', 'room_id');
}
```

### 03

合并分支遇到的问题。

先变基拉库里的代码「git pull --rebase」，处理完冲突后再 push 代码。然后合并分支，合并分支是发现很多地方莫名该了，还好可以在分支管理图形界面里看到具体哪几个文件变动，苯办法，手动把备份文件里的代码复制过来才解决的，接着提交，再 push。

1『小的项目，不要再建分支了，直接在 master 上开发。如果项目里有其他人，每次小步修改后就提交。具体步骤：先把文件暂存，变基拉代码，把暂存里的代码一个个做 commit（因为改动下，基本上就一个文件修改），解决冲突的代码，再推动。如果项目就自己一个人开发，那么修改后直接 commit。』

进服务器拉取遇到的问题，报错：

```
Git 出现冲突 error: Your local changes to the following files would be overwritten by merge:
```

采取下面命令：

```
git stash
git pull
git stash pop
```

接着 git pull 又报错如下：

```
Pull 不可用，因为您尚有未合并的文件。请先在工作区改正文件，
然后酌情使用 'git add/rm <file>' 标记解决方案，
或者使用 'git commit -a'。
```

感觉是最后一个命令 git stash pop 导致的，可能不需要，解决办法是按上面建议的 git commit -a，接着把远程库里的代码随便改点，再在服务器里 pull 一下即可。 

### 04

奇葩的跨域问题，完全是自己 2B，弄了半天终于找到原因。后端代码里调试用的 dd() 函数没有删除。

一直报错跨域，访问不到数据，试了 N 多手段都无效。最后一点一点新建一个最简单的 get 请求，一步步试，也是无意中找到问题的。牢记这个坑！（2020-06-30）

## 03. 细节

### 01. 比较运算符

== 不考虑数据类型，=== 考虑数据类型。模块 3 消除余湿里：

```php
foreach ($equipments as $equipment) {
    if ($equipment->type == 1) {  // 电热设备
        $total = $total + $this->electric($equipment);
    }
    if ($equipment->type == 2) {
        $total = $total + $this->motor($equipment);
    }
    if (!$equipment) {
        $total = $total + $this->other($equipment);
    }
}
```

2、给数组添加元素直接用 \$array[] = XX

官方文档：[PHP: array_push - Manual](https://www.php.net/manual/zh/function.array-push.php)

如果用 array_push() 来给数组增加一个单元，还不如用 \$array[] = ，因为这样没有调用函数的额外负担。

### 02. laravel 里实现软删除

[Eloquent: Getting Started - Laravel - The PHP Framework For Web Artisans](https://laravel.com/docs/7.x/eloquent#soft-deleting)

In addition to actually removing records from your database, Eloquent can also "soft delete" models. When models are soft deleted, they are not actually removed from your database. Instead, a deleted_at attribute is set on the model and inserted into the database. If a model has a non-null deleted_at value, the model has been soft deleted. To enable soft deletes for a model, use the Illuminate\Database\Eloquent\SoftDeletes trait on the model:

```php
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Flight extends Model
{
    use SoftDeletes;
}
```

The SoftDeletes trait will automatically cast the deleted_at attribute to a DateTime / Carbon instance for you.

现在 BaseModel 里实现：

```php
<?php

namespace App\Model;

use App\Exceptions\ModelExceptions;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class BaseModel extends Model
{
    use SoftDeletes;

    const CREATED_AT = 'created_at';
    const UPDATED_AT = 'updated_at';

    protected $datas = ['deleted_at'];

    public $timestamps = true;

    public function fromDateTime($value)
    {
        return strtotime(parent::fromDateTime($value));
    }

    /**
     * 抛出错误信息
     * @param string msg
     * @param int code
     * @throws ModelExceptions
     */
    public function error($code,  $msg = '')
    {
        $msg = $msg ?: ModelExceptions::ERROR[$code];
        throw new ModelExceptions($msg, $code);
    }
}
```

后面用到的数据表单模型都直接继承 BaseModel，比如暖通系统通风的数据模型 NsSystemModel：

```php
<?php

namespace App\Model;

class NsSystemModel extends BaseModel
{
    protected $table = 'ns_system';

    public function monomer()
    {
        return $this->hasOne(MonomerModel::class, 'id', 'monomer_id');
    }

}
```

### 03. 前端包的更新

如果要更新 node 组件的话，记得先把 node_modules 文件夹先删掉，然后「npm install」安装，只是新增包的话可以不删那个文件夹。

### 04. 远程服务器上解决冲突的手段

1、服务器上本地做了修改，pull 不下来。

git reset HEAD 是回退到当前版本。经试验，本地修改的文件，提交到暂存区，然后用这个命令，相当于「反悔」上面的步骤。

git reset HEAD^ 回退到上一版本。感觉这 2 个命令都不好用。

git reset --hard 相当于直接放弃之前的修改，不管是只是本次修改还是已经提交到了暂存区，这个命令好用的。

git checkout -- . 或者 git checkout -- *，这两个命令只是针对本地的修改，即放弃掉本地的修改，但是对已经提交到暂存区的就无能为力了。必须得用「git reset --hard」来放弃。

### 05. 不同版本的构建

最后定的是，生产环境用于公司内的服务器，预发布环境应用于阿里云上的服务器。

```
# 打包正式环境
npm run build:prod

# 打包预发布环境
npm run build:stage
```

配置文件「.env.production」：

```
# just a flag
ENV = 'production'

# base api
VUE_APP_BASE_API = '/prod-api'
VUE_APP_BASE_API_DEF = 'http://192.168.1.38:8081'
```

配置文件「.env.staging」：

```
NODE_ENV = production

# just a flag
ENV = 'staging'

# base api
# VUE_APP_BASE_API = '/stage-api'

VUE_APP_BASE_API = '/prod-api'
VUE_APP_BASE_API_DEF = 'http://test.hg101.vip'
```