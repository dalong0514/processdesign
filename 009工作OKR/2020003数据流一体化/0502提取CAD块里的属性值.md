# 0201. 提取块里的额属性值

## 01. 问题记录

### 1.1 编码问题

最大的问题是编码，导出的无论是 txt 还 csv 电脑里打开是好的，上到服务器中文是乱码，cad 默认出来的是 gb2312 编码的，弄了好久好久才解决。

[[求助]用 lisp 调用 vb 把 ANSI 编码的文件转换成UTF-8 - AutoLISP/Visual LISP 编程技术 - CAD论坛 - 明经CAD社区 - Powered by Discuz!](http://bbs.mjtd.com/thread-82886-1-1.html)

### 1.2 VLAX-GET-ACAD-OBJECT

自己电脑上跑没问题，但在公司电脑上跑（包括公司里其他人的电脑），报错：

```
error: no function definition: VLAX-GET-ACAD-OBJECT
```

解决方案：[error: no function definition: VLAX-GET-ACAD-OBJECT - AutoLISP, Visual LISP & DCL - AutoCAD Forums](https://www.cadtutor.net/forum/topic/19261-error-no-function-definition-vlax-get-acad-object/)

文件开始的地方（函数之外）加下面一行代码：

```
(vl-load-com)
```

目前放在命令说明的语句下面的。

### 1.3 仪表属性块内增加安装位置尺寸和方向属性后无法提取

弄了半天才解决，奇怪的是发现仅仅是因为顺序的问题，把之前最后的正常流量拿到前面去，必须先安装尺寸再安装的方向。

回复：目前找到的原因（不是很确定），lisp 里提取各个属性的顺序只要保持跟 cad 块中各属性的顺序相同即可。（2020-07-27）

## 02. 参考

[Forums - AutoCAD Forums](https://www.cadtutor.net/forum/)

### 01

[SSGET - BLOCK, then Search Descriptions - Page 2 - AutoLISP, Visual LISP & DCL - AutoCAD Forums](https://www.cadtutor.net/forum/topic/64986-ssget-block-then-search-descriptions/page/2/#comments)

```
(defun c:test (/ _getattvalue s v)
 ;; RJP - Simple get attribute value sub .. no error checking
 (defun _getattvalue (block tag)
   (vl-some
     '(lambda (att)
    (cond ((eq (strcase tag) (strcase (vla-get-tagstring att))) (vla-get-textstring att)))
      )
     (vlax-invoke block 'getattributes)
   )
 )
 ;; RJP - added (66 . 1) to filter ( attributed blocks )
 (cond    ((setq
      s (ssget "_C" '(7.244 2.071) '(16.665 10.003) '((0 . "INSERT") (8 . "FTG-Iso") (66 . 1)))
    )
    (foreach en (vl-remove-if 'listp (mapcar 'cadr (ssnamex s)))
      (if (and ;; If we have a value, and it does not match the filter then remove item from selection
           (setq v (_getattvalue (vlax-ename->vla-object en) "Description"))
           ;; Wcmatch example
           ;; (not (wcmatch (strcase v) "*SKSW*,*NISC*,*NIPL*,*THSC*,*WTBW*,*NRSC*,*PL*,*KASC*,*KASW*,"))
           ;; vl-string-search example ( more legible IMO )
           (not (vl-some '(lambda (x) (vl-string-search x (strcase v)))
                 '("SKSW" "NISC" "NIPL" "THSC" "WTBW" "NRSC" "PL" "KASC" "KASW")
            )
           )
          )
        (ssdel en s)
      )
    )
    ;; Highlight selection
    (sssetfirst nil s)
   )
 )
 (princ)
)
(vl-load-com)
```

If you don't need the selection set, it's more logical to just change the layer of the items within the loop.

```
(if (and ;; If we have a value, and it does not match the filter then remove item from selection
	    (setq v (_getattvalue (vlax-ename->vla-object en) "Description"))
	    ;; vl-string-search example ( more legible IMO )
	    (vl-some '(lambda (x) (vl-string-search x (strcase v)))
		     '("SKSW" "NISC" "NIPL" "THSC" "WTBW" "NRSC" "PL" "KASC" "KASW")
	    )
       )
     (entmod (append (entget en) '((8 . "NewLayer"))))
   )
```

### 02

[Using ssget "X" to Get block name if block contain more then 20 lines of attribu](https://www.theswamp.org/index.php?topic=38912.0)

The ssget function can only search the drawing database for primary entities, not subentities such as attributes/vertices.

Therefore, you have two options: the first would be to iterate through all attributed blocks in the drawing, then single out those that have more than 20 attributes:

```
(defun GetBlocksWithMoreThan20Attribs ( / at en i ss )
  (if (setq ss (ssget "_X" '((0 . "INSERT") (66 . 1))))
    (repeat (setq i (sslength ss))
      (setq en (ssname ss (setq i (1- i)))
            at 0
      )
      (while (eq "ATTRIB" (cdr (assoc 0 (entget (setq en (entnext en))))))
        (setq at (1+ at))
      )
      (if (< at 20)
        (ssdel (cdr (assoc 330 (entget en))) ss)
      )
    )
  )
  ss
)
```

1『

上面的代码很有借鉴意义。

```
// 获取块名为 blockname 的块集合，发现块名是中文不行
(setq ss (ssget "X" '((0 . "insert") (2 . "blockname"))))
// 不要选项 "X" 表示手动框选
(setq ss (ssget '((0 . "insert") (2 . "blockname"))))

// 获取所有的块集合
(setq ss (ssget "_X" '((0 . "INSERT") (66 . 1))))

(sslength ss)
```

』

The second would be to iterate through the block table, and collect the names of blocks with more than 20 attribute definitions, then create a selection set of these blocks.

```
(defun GetBlocksWithMoreThan20AttDefs ( / at bd be bl nm )
  (while (setq bd (tblnext "BLOCK" (null bd)))
    (if (= 2 (logand 2 (cdr (assoc 70 bd))))
      (progn
        (setq at 0
              nm (cdr (assoc 2 bd))
              be (tblobjname "BLOCK" nm)
        )
        (while (setq be (entnext be))
          (if (eq "ATTDEF" (cdr (assoc 0 (entget be))))
            (setq at (1+ at))
          )
        )
        (if (<= 20 at)
          (setq bl (cons "," (cons nm bl)))
        )
      )
    )
  )
  (ssget "_X" (list '(0 . "INSERT") '(66 . 1) (cons 2 (apply 'strcat (cdr bl)))))
)
```

The second method will fail however if attributes have been added to the block outside of the block definition, but this is an unlikely case. When entmake'ing a Block Reference (Insert), attributes which do not belong to the Block Definition can be programmatically added to the Insert entity using entmake.

### 03

[Autolisp to Update Titleblock Attributes](https://gist.github.com/rudderdon/d8880c26253634b1a2908c14726f3367)

```
(defun c:magic ()
  (setq osm (getvar "OSMODE"))
  (setq attq (getvar "ATTREQ"))
  (setvar "OSMODE" 0)
  (setvar "ATTREQ" 0)
  (command "-xref" "p" "TbInfo-CP51" "..\\..\\Blks\\TbInfo.dwg")
  (doRevs)
  (doSheet)
  (command "-layer" "thaw" "*|E-REVS-SIGN-1" "on" "*|E-REVS-SIGN-1" "")

  (setvar "OSMODE" osm)
  (setvar "ATTREQ" attq)
)

(defun doRevs ()
  (setq ss (ssget "x" '((0 . "INSERT") (2 . "ATTRIBUTE-BLOCK-NAME"))))
  (setq i 0)
  (if (/= ss nil)
    (progn
      (if (/= nil (ssname ss i))
	(progn
	  (setq ent (entget (ssname ss i)))
	  (setq p1 (cdr (assoc 10 ent)))
	  (setq blk (ssname ss i))
	  (setq entx (entget (entnext (cdr (assoc -1 ent)))))
	  (while (= "ATTRIB" (cdr (assoc 0 entx)))
	    (setq value (cdr (assoc 2 entx)))
	    (if	(= value "REV-NO-1")
	      (progn
		(setq a (cons 1 "0"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "REV-NO-1-DATE")
	      (progn
		(setq a (cons 1 "17.03.10"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "REV-1-DESCRIPTION")
	      (progn
		(setq a (cons 1 "ISSUED FOR XXXXXXXXXXXXXXXXXX"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "REV-NO-2")
	      (progn
		(setq a (cons 1 "1"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "REV-NO-2-DATE")
	      (progn
		(setq a (cons 1 "15.09.10"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "REV-2-DESCRIPTION")
	      (progn
		(setq a (cons 1 "ISSUED FOR XXXXXXXXXXXXXXXXX"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    ****************************************************************************************
	    (setq entx (entget (entnext (cdr (assoc -1 entx)))))
	  )
	  (entupd blk)
	  (setq i (+ 1 i))
	)
      )
      (prompt "Attribute updated successfully. ")
    )
  )
  (princ)
)

(defun doSheet ()

  (setq ss (ssget "x" '((0 . "INSERT") (2 . "BLOCK NAME"))))
  (setq i 0)
  (if (/= ss nil)
    (progn
      (if (/= nil (ssname ss i))
	(progn
	  (setq ent (entget (ssname ss i)))
	  (setq p1 (cdr (assoc 10 ent)))
	  (setq blk (ssname ss i))
	  (setq entx (entget (entnext (cdr (assoc -1 ent)))))
	  (while (= "ATTRIB" (cdr (assoc 0 entx)))
	    (setq value (cdr (assoc 2 entx)))
	    (if	(= value "REV-NO")
	      (progn
		(setq a (cons 1 "1"))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )
	    (if	(= value "PROJECT-JOB-NO")
	      (progn
		(setq a (cons 1 ""))
		(setq b (assoc 1 entx))
		(entmod (subst a b entx))
	      )
	    )

	    ****************************************************************************************
	    (setq entx (entget (entnext (cdr (assoc -1 entx)))))
	  )
	  (entupd blk)
	  (setq i (+ 1 i))
	)
      )
      (prompt "Attribute updated successfully. ")
    )
  )
  (princ)
)
```

## 03. 代码实现

### 01

输出成 json 格式：

一版

```
(defun c:dataflow (/ fn f)
  (print "give the file name")
  (setq fn (getstring "\nfilename: "))
  (setq currentDir (getvar "dwgprefix"))
  (setq fn (strcat currentDir fn ".txt"))
  (setq f (open fn "w"))
  (PipeArrowLeft f)
  (close f)
)

(defun c:gspipe (/ fn f)
  (print "give the file name")
  (setq fn (getstring "\nfilename: "))
  (setq currentDir (getvar "dwgprefix"))
  (setq fn (strcat currentDir fn ".txt"))
  (setq f (open fn "w"))
  (PipeArrowLeft f)
  (close f)

  (file-encode-trans fn "gb2312" "utf-8")
)

; extarct data form PipeArrowLeft Block
(defun PipeArrowLeft (f / ss i N index)

  (setq ss (ssget "x" '((0 . "INSERT") (2 . "PipeArrowLeft"))))

  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (princ (strcat "{\"source_data\": [\n") f)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (princ "{" f)
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "PIPENUM")
                (progn
                  (setq pipenum (cdr (assoc 1 entx)))
                  (princ (strcat "\"pipenum\": \"" pipenum "\",") f)
                )
              )
              (if (= value "SUBSTANCE")
                (progn
                  (setq substace (cdr (assoc 1 entx)))
                  (princ (strcat "\"substace\": \"" substace "\",") f)
                )
              )
              (if (= value "TEMP")
                (progn
                  (setq temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"temp\": \"" temp "\",") f)
                )
              )
              (if (= value "PRESSURE")
                (progn
                  (setq pressure (cdr (assoc 1 entx)))
                  (princ (strcat "\"pressure\": \"" pressure "\",") f)
                )
              )
              (if (= value "PHASE")
                (progn
                  (setq phase (cdr (assoc 1 entx)))
                  (princ (strcat "\"phase\": \"" phase "\",") f)
                )
              )
              (if (= value "FROM")
                (progn
                  (setq fromP (cdr (assoc 1 entx)))
                  (princ (strcat "\"form\": \"" fromP "\",") f)
                )
              )
              (if (= value "TO")
                (progn
                  (setq toP (cdr (assoc 1 entx)))
                  (princ (strcat "\"to\": \"" toP "\",") f)
                )
              )
              (if (= value "INSULATION")
                (progn
                  (setq insulation (cdr (assoc 1 entx)))
                  (princ (strcat "\"insulation\": \"" insulation "\",") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (princ "},\n" f)
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
      )
      (princ "]}" f)
      (princ "\ntotal pipes: ")
      (princ N)
    )
  )
)

(defun file-encode-trans (file charset1 charset2 / obj encode)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset1);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke-method obj 'loadfromfile file)
  (setq encode (vlax-invoke obj 'readtext))
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset2);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke obj 'writetext encode)
  (vlax-invoke-method obj 'savetofile file 2);1新建，2覆盖
  (vlax-invoke obj 'flush);将缓存中的数据强制输出
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
)

```

二版：

```
;冯大龙编于 2020 年
(princ "\nthe specification: ")

; get the current file direction
(defun getFileDir (/ fn)
  (print "give the file name")
  (setq fn (getstring "\nfilename: "))
  (setq currentDir (getvar "dwgprefix"))
  (setq fn (strcat currentDir fn ".txt"))
)

;  the command for extarcting data from the for PipeArrow Blocks
(defun c:gspipe (/ fn f ssLeft ssRight)
  (setq fn (getFileDir))
  (setq f (open fn "w"))
  (setq ssLeft (ssget "x" '((0 . "INSERT") (2 . "PipeArrowLeft"))))
  (setq ssRight (ssget "x" '((0 . "INSERT") (2 . "PipeArrowRight"))))
  (ExtactPipeArrow f ssLeft)
  (ExtactPipeArrow f ssRight)
  (close f)
  ; tansfor the encode
  (file-encode-trans fn "gb2312" "utf-8")
  (princ "\nCompleted!")
  (princ)
)

; the command for extarcting data from globalVentilation Block
(defun c:nsglobal (/ fn f)
  (setq fn (getFileDir))
  (setq f (open fn "w"))
  (setq ssRoom (ssget "x" '((0 . "INSERT") (2 . "RoomData"))))
  (setq ssSubstance (ssget "x" '((0 . "INSERT") (2 . "SubstanceData"))))
  (setq ssHotWet (ssget "x" '((0 . "INSERT") (2 . "HotWetData"))))
  (ExtactGlobalRoom f ssRoom)
  (ExtactGlobalSubstance f ssSubstance)
  (ExtactGlobalHotWet f ssHotWet)
  (close f)
  ; tansfor the encode
  (file-encode-trans fn "gb2312" "utf-8")
)

; extarct data form HotWetData Block
(defun ExtactGlobalHotWet (f ss / N index i ent blk entx value)
  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (princ "{" f)
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "ROOM_NUM")
                (progn
                  (setq room_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_num\": \"" room_num "\",") f)
                  (princ (strcat "\"block_data\": \"" "hotwet" "\",") f)
                )
              )
              (if (= value "EQUIPMENT_NUM")
                (progn
                  (setq equipment_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"equipment_num\": \"" equipment_num "\",") f)
                )
              )
              (if (= value "TYPE")
                (progn
                  (setq typeid (cdr (assoc 1 entx)))
                  (princ (strcat "\"type\": \"" typeid "\",") f)
                )
              )
              (if (= value "AIR_EXHAUST")
                (progn
                  (setq air_exhaust (cdr (assoc 1 entx)))
                  (princ (strcat "\"air_exhaust\": \"" air_exhaust "\",") f)
                )
              )
              (if (= value "PRESERVE_HEAT")
                (progn
                  (setq preserve_heat (cdr (assoc 1 entx)))
                  (princ (strcat "\"preserve_heat\": \"" preserve_heat "\",") f)
                )
              )
              (if (= value "POWER")
                (progn
                  (setq power (cdr (assoc 1 entx)))
                  (princ (strcat "\"power\": \"" power "\",") f)
                )
              )
              (if (= value "SURFACE_AREA")
                (progn
                  (setq surface_area (cdr (assoc 1 entx)))
                  (princ (strcat "\"surface_area\": \"" surface_area "\",") f)
                )
              )
              (if (= value "SURFACE_TEMP")
                (progn
                  (setq surface_temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"surface_temp\": \"" surface_temp "\",") f)
                )
              )
              (if (= value "WATER_AREA")
                (progn
                  (setq water_area (cdr (assoc 1 entx)))
                  (princ (strcat "\"water_area\": \"" water_area "\",") f)
                )
              )
              (if (= value "WATER_TEMP")
                (progn
                  (setq water_temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"water_temp\": \"" water_temp "\"") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (princ "}\n" f)
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
        (princ)
      )
    )
  )
)

; extarct data form SubstanceData Block
(defun ExtactGlobalSubstance (f ss / N index i ent blk entx value)
  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (princ "{" f)
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "ROOM_NUM")
                (progn
                  (setq room_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_num\": \"" room_num "\",") f)
                  (princ (strcat "\"block_data\": \"" "substance" "\",") f)
                )
              )
              (if (= value "SUBSTANCE_NAME")
                (progn
                  (setq substance_name (cdr (assoc 1 entx)))
                  (princ (strcat "\"substance_name\": \"" substance_name "\",")
                   f)
                )
              )
              (if (= value "VALUE_NUM")
                (progn
                  (setq value_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"value_num\": \"" value_num "\",") f)
                )
              )
              (if (= value "PUMPSEAL_NUM")
                (progn
                  (setq pumpseal_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"pumpseal_num\": \"" pumpseal_num "\",") f)
                )
              )
              (if (= value "FLANGE_NUM")
                (progn
                  (setq flange_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"flange_num\": \"" flange_num "\",") f)
                )
              )
              (if (= value "DISCHARGE_NUM")
                (progn
                  (setq discharge_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"discharge_num\": \"" discharge_num "\",") f)
                )
              )
              (if (= value "SAFETY_NUM")
                (progn
                  (setq safety_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"safety_num\": \"" safety_num "\",") f)
                )
              )
              (if (= value "COMPRESS_NUM")
                (progn
                  (setq compress_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"compress_num\": \"" compress_num "\"") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (princ "}\n" f)
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
        (princ)
      )
    )
  )
)

; extarct data form RoomData Block
(defun ExtactGlobalRoom (f ss / N index i ent blk entx value)
  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (princ "{" f)
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "ROOM_NUM")
                (progn
                  (setq room_num (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_num\": \"" room_num "\",") f)
                  (princ (strcat "\"block_data\": \"" "room" "\",") f)
                )
              )
              (if (= value "ROOM_NAME")
                (progn
                  (setq room_name (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_name\": \"" room_name "\",") f)
                )
              )
              (if (= value "ROOM_AREA")
                (progn
                  (setq room_area (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_area\": \"" room_area "\",") f)
                )
              )
              (if (= value "ROOM_HEIGHT")
                (progn
                  (setq room_height (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_height\": \"" room_height "\",") f)
                )
              )
              (if (= value "ROOM_PRESSURE")
                (progn
                  (setq room_pressure (cdr (assoc 1 entx)))
                  (princ (strcat "\"room_pressure\": \"" room_pressure "\",") f)
                )
              )
              (if (= value "SUMMER_TEMP")
                (progn
                  (setq summer_temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"summer_temp\": \"" summer_temp "\",") f)
                )
              )
              (if (= value "SUMMER_REHUMIDITY")
                (progn
                  (setq summer_rehumidity (cdr (assoc 1 entx)))
                  (princ (strcat "\"summer_rehumidity\": \"" summer_rehumidity "\",") f)
                )
              )
              (if (= value "WINTER_TEMP")
                (progn
                  (setq winter_temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"winter_temp\": \"" winter_temp "\",") f)
                )
              )
              (if (= value "WINTER_REHUMIDITY")
                (progn
                  (setq winter_rehumidity (cdr (assoc 1 entx)))
                  (princ (strcat "\"winter_rehumidity\": \"" winter_rehumidity "\"") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (princ "}\n" f)
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
        (princ)
      )
    )
  )
)

; extarct data form the for PipeArrow Blocks
(defun ExtactPipeArrow (f ss / N index i ent blk entx value pipenum substance temp pressure phase fromP toP insulation)
  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (princ "{" f)
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "PIPENUM")
                (progn
                  (setq pipenum (cdr (assoc 1 entx)))
                  (princ (strcat "\"pipenum\": \"" pipenum "\",") f)
                )
              )
              (if (= value "SUBSTANCE")
                (progn
                  (setq substance (cdr (assoc 1 entx)))
                  (princ (strcat "\"substance\": \"" substance "\",") f)
                )
              )
              (if (= value "TEMP")
                (progn
                  (setq temp (cdr (assoc 1 entx)))
                  (princ (strcat "\"temp\": \"" temp "\",") f)
                )
              )
              (if (= value "PRESSURE")
                (progn
                  (setq pressure (cdr (assoc 1 entx)))
                  (princ (strcat "\"pressure\": \"" pressure "\",") f)
                )
              )
              (if (= value "PHASE")
                (progn
                  (setq phase (cdr (assoc 1 entx)))
                  (princ (strcat "\"phase\": \"" phase "\",") f)
                )
              )
              (if (= value "FROM")
                (progn
                  (setq fromP (cdr (assoc 1 entx)))
                  (princ (strcat "\"from\": \"" fromP "\",") f)
                )
              )
              (if (= value "TO")
                (progn
                  (setq toP (cdr (assoc 1 entx)))
                  (princ (strcat "\"to\": \"" toP "\",") f)
                )
              )
              (if (= value "INSULATION")
                (progn
                  (setq insulation (cdr (assoc 1 entx)))
                  (princ (strcat "\"insulation\": \"" insulation "\"") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (princ "}\n" f)
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
        (princ)
      )
    )
  )
)


(defun file-encode-trans (file charset1 charset2 / obj encode)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset1);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke-method obj 'loadfromfile file)
  (setq encode (vlax-invoke obj 'readtext))
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset2);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke obj 'writetext encode)
  (vlax-invoke-method obj 'savetofile file 2);1新建，2覆盖
  (vlax-invoke obj 'flush);将缓存中的数据强制输出
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
)

```

生成 csv 文件：

```
(defun c:dataflow (/ fn f)
  (print "give the file name")
  (setq fn (getstring "\nfilename: "))
  (setq currentDir (getvar "dwgprefix"))
  (setq fn (strcat currentDir fn ".txt"))
  (setq f (open fn "w"))
  (PipeArrowLeft f)
  (close f)
)

(defun c:gspipe (/ fn f)
  (print "give the file name")
  (setq fn (getstring "\nfilename: "))
  (setq currentDir (getvar "dwgprefix"))
  (setq fn (strcat currentDir fn ".csv"))
  (setq f (open fn "w"))
  (PipeArrowLeft f)
  (close f)

  (file-encode-trans fn "gb2312" "utf-8")
)

; extarct data form PipeArrowLeft Block
(defun PipeArrowLeft (f / ss i N index)

  (setq ss (ssget "x" '((0 . "INSERT") (2 . "PipeArrowLeft"))))

  (if (/= ss nil)
    (progn
      (setq N (sslength ss))
      (setq index 0)
      (princ (strcat "pipenum,substace,temp,pressure,phase,form,to,insulation\n") f)
      (setq i index)
      (repeat N
        (if (/= nil (ssname ss i))
          (progn
            (setq ent (entget (ssname ss i)))
            (setq blk (ssname ss i))
            (setq entx (entget (entnext (cdr (assoc -1 ent)))))
            (while (= "ATTRIB" (cdr (assoc 0 entx)))
              (setq value (cdr (assoc 2 entx)))
              (if (= value "PIPENUM")
                (progn
                  (setq pipenum (cdr (assoc 1 entx)))
                  (princ (strcat pipenum ",") f)
                )
              )
              (if (= value "SUBSTANCE")
                (progn
                  (setq substace (cdr (assoc 1 entx)))
                  (princ (strcat substace ",") f)
                )
              )
              (if (= value "TEMP")
                (progn
                  (setq temp (cdr (assoc 1 entx)))
                  (princ (strcat temp ",") f)
                )
              )
              (if (= value "PRESSURE")
                (progn
                  (setq pressure (cdr (assoc 1 entx)))
                  (princ (strcat pressure ",") f)
                )
              )
              (if (= value "PHASE")
                (progn
                  (setq phase (cdr (assoc 1 entx)))
                  (princ (strcat phase ",") f)
                )
              )
              (if (= value "FROM")
                (progn
                  (setq fromP (cdr (assoc 1 entx)))
                  (princ (strcat fromP ",") f)
                )
              )
              (if (= value "TO")
                (progn
                  (setq toP (cdr (assoc 1 entx)))
                  (princ (strcat toP ",") f)
                )
              )
              (if (= value "INSULATION")
                (progn
                  (setq insulation (cdr (assoc 1 entx)))
                  (princ (strcat insulation "\n") f)
                )
              )
              ; 下面的语句必须设置，否则无限写数据
              (setq entx (entget (entnext (cdr (assoc -1 entx)))))
            )
            (entupd blk)
            (setq i (+ 1 i))
          )
        )
        (setq index (+ 1 index))
      )
      (princ "\ntotal pipes: ")
      (princ N)
    )
  )
)

(defun file-encode-trans (file charset1 charset2 / obj encode)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset1);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke-method obj 'loadfromfile file)
  (setq encode (vlax-invoke obj 'readtext))
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
  (setq obj (vlax-create-object "ADODB.Stream"))
  (vlax-put-property obj 'type 2);1二进制读取 2文本模读取
  (vlax-put-property obj 'mode 3);1-读,2-写,3-读写
  (vlax-invoke obj 'open)
  (vlax-put-property obj "charset" charset2);;unicode;utf-8;ascii;gb2312;big5;gbk
  (vlax-invoke obj 'writetext encode)
  (vlax-invoke-method obj 'savetofile file 2);1新建，2覆盖
  (vlax-invoke obj 'flush);将缓存中的数据强制输出
  (vlax-invoke obj 'close)
  (vlax-release-object obj)
)

```
